<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Appear" xml:space="preserve">
    <value>出现</value>
  </data>
  <data name="KeywordIn" xml:space="preserve">
    <value>位于</value>
  </data>
  <data name="Language" xml:space="preserve">
    <value>2052</value>
  </data>
  <data name="Only" xml:space="preserve">
    <value>只</value>
  </data>
  <data name="OrKeywordWithSpaces" xml:space="preserve">
    <value> 或 </value>
  </data>
  <data name="TechniqueFormat_AlmostLockedSetsWWingStep" xml:space="preserve">
    <value>{Name}：ALS {Als1Str} 和 {Als2Str} 以共轭对 {ConjStr} 关联起来；其中 W = {WStr}、X = {XStr} =&gt; {ElimStr}</value>
  </data>
  <data name="TechniqueFormat_AlmostLockedSetsXyWingStep" xml:space="preserve">
    <value>{Name}：{Als1Str} -&gt; {BridgeStr} -&gt; {Als2Str}；其中 X = {XStr}、Y = {YStr}、Z = {ZStr} =&gt; {ElimStr}</value>
  </data>
  <data name="TechniqueFormat_AlmostLockedSetsXzRule" xml:space="preserve">
    <value>{Name}：ALS #1：{Als1Str}、ALS #2：{Als2Str}、X = {XStr}{ZResultStr} =&gt; {ElimStr}</value>
  </data>
  <data name="TechniqueFormat_AlternatingInferenceChainStep" xml:space="preserve">
    <value>{Name}：链 {ChainStr} =&gt; {ElimStr}</value>
  </data>
  <data name="TechniqueFormat_AvoidableRectangleWithHiddenSingleStep" xml:space="preserve">
    <value>{Name}：数字 {D1Str} 和 {D2Str} 位于单元格 {CellsStr} 构成结构，并带排除法：如果单元格 {BaseCellStr} 填上了数字 {Digit1Str}，{RegionStr} 区域仅能让 {TargetCellStr} 填入该数字，便出现致命形式 =&gt; {ElimStr}</value>
  </data>
  <data name="TechniqueFormat_BinaryChainingStep" xml:space="preserve">
    <value>{Name}：可以证明如果 {AnchorCandidateStr} 为{AnchorIsTrueOrFalseStr}时会产生矛盾 =&gt; {ElimStr}</value>
  </data>
  <data name="TechniqueFormat_BivalueUniversalGraveMultipleStep" xml:space="preserve">
    <value>{Name}：真数为 {CandidatesStr} =&gt; {ElimStr}</value>
  </data>
  <data name="TechniqueFormat_BivalueUniversalGraveType1Step" xml:space="preserve">
    <value>{Name}：{ElimStr}</value>
  </data>
  <data name="TechniqueFormat_BivalueUniversalGraveType2Step" xml:space="preserve">
    <value>{Name}：单元格 {CellsStr} 里包含额外数字 {ExtraDigitStr} =&gt; {ElimStr}</value>
  </data>
  <data name="TechniqueFormat_BivalueUniversalGraveType3Step" xml:space="preserve">
    <value>{Name}：真数 {TrueCandidatesStr}，伴有{SubsetTypeStr}{SizeStrZhCn}于单元格 {CellsStr} 里，涉及数字 {ExtraDigitsStr} =&gt; {ElimStr}</value>
  </data>
  <data name="TechniqueFormat_BivalueUniversalGraveType4Step" xml:space="preserve">
    <value>{Name}：位于单元格 {CellsStr} 里的数字 {DigitsStr}，带有一个共轭对 {ConjStr} =&gt; {ElimStr}</value>
  </data>
  <data name="TechniqueFormat_BivalueUniversalGraveXzStep" xml:space="preserve">
    <value>{Name}：数字 {DigitStr} 位于单元格 {CellsStr} 里，并带有额外单元格 {ExtraCellStr} =&gt; {ElimStr}</value>
  </data>
  <data name="TechniqueFormat_CellChainingStep" xml:space="preserve">
    <value>{Name}：可以通过强制链来证明得到 {SourceCellStr} 里的所有候选数全部为假 =&gt; {ElimStr}</value>
  </data>
  <data name="TechniqueFormat_ContinuousNiceLoopStep" xml:space="preserve">
    <value>{Name}：环 {ChainStr} =&gt; {ElimStr}</value>
  </data>
  <data name="TechniqueFormat_EmptyRectangleIntersectionPairStep" xml:space="preserve">
    <value>{Name}：数字 {Digit1Str} 和 {Digit2Str} 位于双值格 {StartCellStr} 和 {EndCellStr} 里，并在区域 {RegionStr} 里带有此两数交织起来的空矩形 =&gt; {ElimStr}</value>
  </data>
  <data name="TechniqueFormat_ExtendedRectangleType1Step" xml:space="preserve">
    <value>{Name}：数字 {DigitsStr} 位于单元格 {CellsStr} 里构成结构 =&gt; {ElimStr}</value>
  </data>
  <data name="TechniqueFormat_ExtendedRectangleType2Step" xml:space="preserve">
    <value>{Name}：数字 {DigitsStr} 位于单元格 {CellsStr} 里构成结构，带有额外数字 {ExtraDigitStr} =&gt; {ElimStr}</value>
  </data>
  <data name="TechniqueFormat_ExtendedRectangleType3Step" xml:space="preserve">
    <value>{Name}：数字 {DigitsStr} 位于单元格 {CellsStr} 里构成结构，在区域 {RegionStr} 带有数组，涉及单元格 {ExtraCellsStr} 的数字 {ExtraDigitsStr} =&gt; {ElimStr}</value>
  </data>
  <data name="TechniqueFormat_ExtendedRectangleType4Step" xml:space="preserve">
    <value>{Name}：数字 {DigitsStr} 位于单元格 {CellsStr} 里构成结构，带有共轭对 {ConjStr} =&gt; {ElimStr}</value>
  </data>
  <data name="TechniqueFormat_ExtendedSubsetPrincipleWithDuplicate" xml:space="preserve">
    <value>{Name}：只有数字 {EspDigitStr} 在 {CellsStr} 里可以重复出现 =&gt; {ElimStr}</value>
  </data>
  <data name="TechniqueFormat_ExtendedSubsetPrincipleWithoutDuplicate" xml:space="preserve">
    <value>{Name}：所有在 {CellsStr} 里面的数字都不相同 =&gt; {ElimStr}</value>
  </data>
  <data name="TechniqueFormat_QiuDeadlyPatternLockedTypeStep" xml:space="preserve">
    <value>{Name}：如果所有这 {Number} 个候选数都为假的话，单元格 {PatternStr} 将产生致命形式 =&gt; {ElimStr}</value>
  </data>
  <data name="TechniqueFormat_QiuDeadlyPatternType1Step" xml:space="preserve">
    <value>{Name}：如果 {CandidateStr} 全为假的话，单元格 {PatternStr} 将产生致命形式 =&gt; {ElimStr}</value>
  </data>
  <data name="TechniqueFormat_QiuDeadlyPatternType2Step" xml:space="preserve">
    <value>{Name}：如果所有位于单元格 {PatternStr} 里的数字 {ExtraDigitStr} 全部为假的话，则结构将产生致命形式 =&gt; {ElimStr}</value>
  </data>
  <data name="TechniqueFormat_QiuDeadlyPatternType3Step" xml:space="preserve">
    <value>{Name}：单元格 {PatternStr} 不会产生致命形式当且仅当数字 {DigitsStr} 在单元格 {CellsStr} 里会构成显性{SubsetName} =&gt; {ElimStr}</value>
  </data>
  <data name="TechniqueFormat_QiuDeadlyPatternType4Step" xml:space="preserve">
    <value>{Name}：如果涉及结构的、和共轭对 {ConjStr} 涉及外的数字被放在了共轭对上，单元格 {PatternStr} 将产生致命形式 =&gt; {ElimStr}</value>
  </data>
  <data name="TechniqueFormat_RegionChainingStep" xml:space="preserve">
    <value>{Name}：可以使用强制链证得位于区域 {RegionStr} 的数字 {DigitStr} 全为假的矛盾 =&gt; {ElimStr}</value>
  </data>
  <data name="TechniqueFormat_UniqueLoopType1Step" xml:space="preserve">
    <value>{Name}：数字 {Digit1Str} 和 {Digit2Str} 位于单元格 {LoopStr} 里构成结构 =&gt; {ElimStr}</value>
  </data>
  <data name="TechniqueFormat_UniqueLoopType2Step" xml:space="preserve">
    <value>{Name}：数字 {Digit1Str} 和 {Digit2Str} 位于单元格 {LoopStr} 里构成结构，带有额外数字 {ExtraDigitStr} =&gt; {ElimStr}</value>
  </data>
  <data name="TechniqueFormat_UniqueLoopType3Step" xml:space="preserve">
    <value>{Name}：数字 {Digit1Str} 和 {Digit2Str} 位于单元格 {LoopStr} 里构成结构，带有显性{SubsetName}、额外数字 {DigitsStr}，单元格为 {SubsetCellsStr} =&gt; {ElimStr}</value>
  </data>
  <data name="TechniqueFormat_UniqueLoopType4Step" xml:space="preserve">
    <value>{Name}：数字 {Digit1Str} 和 {Digit2Str} 位于单元格 {LoopStr} 里构成结构，带有共轭对 {ConjStr} =&gt; {ElimStr}</value>
  </data>
  <data name="TechniqueFormat_UniquePolygonType1Step" xml:space="preserve">
    <value>{Name}：数字 {DigitsStr} 位于单元格 {CellsStr} 里 =&gt; {ElimStr}</value>
  </data>
  <data name="TechniqueFormat_UniquePolygonType2Step" xml:space="preserve">
    <value>{Name}：数字 {DigitsStr} 位于单元格 {CellsStr} 里，带有一个额外数字 {ExtraDigitStr} =&gt; {ElimStr}</value>
  </data>
  <data name="TechniqueFormat_UniquePolygonType3Step" xml:space="preserve">
    <value>{Name}：数字 {DigitsStr} 位于单元格 {CellsStr} 里，在单元格 {ExtraCellsStr} 里带有额外数字 {ExtraDigitsStr} =&gt; {ElimStr}</value>
  </data>
  <data name="TechniqueFormat_UniquePolygonType4Step" xml:space="preserve">
    <value>{Name}：数字 {DigitsStr} 位于单元格 {CellsStr} 里，带有一个关于数字 {ExtraCombStr} 的共轭组，位于单元格 {ConjRegionStr} 里 =&gt; {ElimStr}</value>
  </data>
  <data name="TechniqueFormat_UniqueRectangle2DOr3XStep" xml:space="preserve">
    <value>{Name}：数字 {D1Str} 和 {D2Str} 在结构 {CellsStr} 里，X 为 {XDigitStr}、Y 为 {YDigitStr}、双值格为 {XYCellsStr} =&gt; {ElimStr}</value>
  </data>
  <data name="TechniqueFormat_UniqueRectangleType1Step" xml:space="preserve">
    <value>{Name}：数字 {D1Str} 和 {D2Str} 在结构 {CellsStr} 里 =&gt; {ElimStr}</value>
  </data>
  <data name="TechniqueFormat_UniqueRectangleType2Step" xml:space="preserve">
    <value>{Name}：数字 {D1Str} 和 {D2Str} 在结构 {CellsStr} 里，带额外数字 {ExtraDigitStr} =&gt; {ElimStr}</value>
  </data>
  <data name="TechniqueFormat_UniqueRectangleType3Step" xml:space="preserve">
    <value>{Name}：数字 {D1Str} 和 {D2Str} 在结构 {CellsStr} 里，带额外数字 {DigitsStr} {OnlyKeywordZhCn}在区域 {RegionStr} 的 {CellsStr} 这几格里{AppearLimitKeyword} =&gt; {ElimStr}</value>
  </data>
  <data name="TechniqueFormat_UniqueRectangleWithConjugatePairStep" xml:space="preserve">
    <value>{Name}：数字 {D1Str} 和 {D2Str} 在结构 {CellsStr} 里，并带共轭对 {ConjPairsStr} =&gt; {ElimStr}</value>
  </data>
  <data name="TechniqueFormat_UniqueRectangleWithSueDeCoqStep" xml:space="preserve">
    <value>{Name}：数字 {D1Str} 和 {D2Str} 在结构 {CellsStr} 里，带一个简化版的融合待定数组存在于单元格 {MergedCellsStr} 里，涉及数字 {DigitsStr} =&gt; {ElimStr}</value>
  </data>
  <data name="TechniqueFormat_UniqueRectangleWithUnknownCoveringStep" xml:space="preserve">
    <value>{Name}：数字 {D1Str} 和 {D2Str} 在结构 {CellsStr} 里，带代数结构：设单元格 {TargetCellStr} 填入 X（X 是 {DigitsStr} 其一），则四个单元格将构成关于 X 和数字 {ExtraDigitStr} 的唯一矩形致命形式 =&gt; {ElimStr}</value>
  </data>
  <data name="TechniqueFormat_UniqueRectangleWithWingStep" xml:space="preserve">
    <value>{Name}：数字 {D1Str} 和 {D2Str} 在结构 {CellsStr} 里，带一个简化版的融合待定数组存在于单元格 {MergedCellsStr} 里，涉及数字 {DigitsStr} =&gt; {ElimStr}</value>
  </data>
  <data name="TechniqueFormat_UniqueSquareType1Step" xml:space="preserve">
    <value>{Name}：如果候选数 {CandidateStr} 为假，则位于单元格 {CellsStr} 的数字 {DigitsStr} 将构成致命形式 =&gt; {ElimStr}</value>
  </data>
  <data name="TechniqueFormat_UniqueSquareType2Step" xml:space="preserve">
    <value>{Name}：如果数字 {ExtraDigitStr} 在单元格 {CellsStr} 里全部为假，则剩余数字 {DigitsStr} 在这些格子里将构成致命形式 =&gt; {ElimStr}</value>
  </data>
  <data name="TechniqueFormat_UniqueSquareType3Step" xml:space="preserve">
    <value>{Name}：如果数字 {ExtraDigitStr} 在单元格 {ExtraCellsStr} 里不构成显性{SubsetName}的话，则数字 {DigitsStr} 在单元格 {CellsStr} 里将构成致命形式 =&gt; {ElimStr}</value>
  </data>
  <data name="TechniqueFormat_UniqueSquareType4Step" xml:space="preserve">
    <value>{Name}：如果共轭区域 {ConjStr} 无法填入数字 {Digit1Str} 或者 {Digit2Str} 的话，数字 {DigitsStr} 在单元格 {CellsStr} 里将形成致命形式 =&gt; {ElimStr}</value>
  </data>
</root>