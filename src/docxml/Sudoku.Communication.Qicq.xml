<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Sudoku.Communication.Qicq</name>
    </assembly>
    <members>
        <member name="T:Sudoku.Communication.Qicq.AppLifecycle.EnvironmentData">
            <summary>
            Provides with environment data.
            </summary>
        </member>
        <member name="F:Sudoku.Communication.Qicq.AppLifecycle.EnvironmentData.EnvironmentCommandExecuting">
            <summary>
            The current executing command.
            </summary>
        </member>
        <member name="F:Sudoku.Communication.Qicq.AppLifecycle.EnvironmentData.Puzzle">
            <summary>
            The puzzle.
            </summary>
        </member>
        <member name="F:Sudoku.Communication.Qicq.AppLifecycle.EnvironmentData.Painter">
            <summary>
            The painter.
            </summary>
        </member>
        <member name="P:Sudoku.Communication.Qicq.AppLifecycle.EnvironmentData.IsDrawingEnvironment">
            <summary>
            Determines whether the current command environment is being drawing.
            </summary>
        </member>
        <member name="T:Sudoku.Communication.Qicq.Models.UserData">
            <summary>
            Defines a user data.
            </summary>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Models.UserData.QQ">
            <summary>
            The user's QQ number.
            </summary>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Models.UserData.Score">
            <summary>
            Indicates the user's score.
            </summary>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Models.UserData.ComboCheckedIn">
            <summary>
            Indicates the number of continuous days that the user has checked in.
            </summary>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Models.UserData.LastCheckIn">
            <summary>
            Indicates the last time checked in of the current user.
            </summary>
        </member>
        <member name="T:Sudoku.Communication.Qicq.Permission.InternalExtensions">
            <summary>
            Provides with internal extension methods.
            </summary>
        </member>
        <member name="M:Sudoku.Communication.Qicq.Permission.InternalExtensions.CanHandleInvitationOrJoinRequestAsync(Mirai.Net.Sessions.MiraiBot,System.String)">
            <summary>
            Determines whether the specified <see cref="T:Mirai.Net.Sessions.MiraiBot"/> instance supports permission on handling requests
            of adding or inviting message about the specified group.
            </summary>
            <param name="this">The <see cref="T:Mirai.Net.Sessions.MiraiBot"/> instance.</param>
            <param name="groupId">The group ID.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="T:Sudoku.Communication.Qicq.Strings.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Strings.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Strings.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Strings.Resources.AdminQQ">
            <summary>
              Looks up a localized string similar to 747507738.
            </summary>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Strings.Resources.BotQQ">
            <summary>
              Looks up a localized string similar to 979329690.
            </summary>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Strings.Resources.BotSettingsFolderName">
            <summary>
              Looks up a localized string similar to BotData.
            </summary>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Strings.Resources.CachedPictureFolderName">
            <summary>
              Looks up a localized string similar to TempPictures.
            </summary>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Strings.Resources.HostPort">
            <summary>
              Looks up a localized string similar to localhost:8080.
            </summary>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Strings.Resources.SudokuGroupQQ">
            <summary>
              Looks up a localized string similar to 924849321.
            </summary>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Strings.Resources.UserSettingsFolderName">
            <summary>
              Looks up a localized string similar to Users.
            </summary>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Strings.Resources.VerifyKey">
            <summary>
              Looks up a localized string similar to helloworld.
            </summary>
        </member>
        <member name="T:Mirai.Net.Data.Shared.GroupExtensions">
            <summary>
            Provides with extension methods on <see cref="T:Mirai.Net.Data.Shared.Group"/>.
            </summary>
            <seealso cref="T:Mirai.Net.Data.Shared.Group"/>
        </member>
        <member name="M:Mirai.Net.Data.Shared.GroupExtensions.GetMemberAsync(Mirai.Net.Data.Shared.Group,System.String)">
            <summary>
            Gets the member whose QQ or name is specified one.
            </summary>
            <param name="this">The group.</param>
            <param name="nameOrId">The QQ number or target member's name.</param>
            <returns>The target member returned. If none found, <see langword="null"/>.</returns>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Mirai.Net.Data.Shared.GroupExtensions.GetMemberFromQQAsync(Mirai.Net.Data.Shared.Group,System.String)">
            <summary>
            Gets the member whose QQ number is the specified one.
            </summary>
            <param name="this">The group.</param>
            <param name="qq">The QQ number.</param>
            <returns>The target member returned. If none found, <see langword="null"/>.</returns>
        </member>
        <member name="T:OneOf.OneOfExtensions">
            <summary>
            Provides extension methods on <see cref="N:OneOf"/> types.
            </summary>
            <seealso cref="N:OneOf"/>
        </member>
        <member name="M:OneOf.OneOfExtensions.Deconstruct``2(OneOf.OneOf{``0,``1},System.Boolean@,System.Boolean@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
						public static void Deconstruct(out string name, out int age)
						{
						    name = Name;
						    age = Age;
						}
						</code>
						The following code will be legal.
						<code>
						// Use explicitly typed variables to get a deconstruction.
						(string name, int age) = student;

						// Or use the type inferring to omit the type of each variable having been deconstructed.
						var (name, age) = student;

						// Of course, you can also use the invocation to get values.
						student.Deconstruct(out string name, out int age);
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
						if (student is (name: var name, age: &gt;= 18))
						{
						    Console.WriteLine(name);
						}
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="M:OneOf.OneOfExtensions.Deconstruct``3(OneOf.OneOf{``0,``1,``2},System.Boolean@,System.Boolean@,System.Boolean@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
						public static void Deconstruct(out string name, out int age)
						{
						    name = Name;
						    age = Age;
						}
						</code>
						The following code will be legal.
						<code>
						// Use explicitly typed variables to get a deconstruction.
						(string name, int age) = student;

						// Or use the type inferring to omit the type of each variable having been deconstructed.
						var (name, age) = student;

						// Of course, you can also use the invocation to get values.
						student.Deconstruct(out string name, out int age);
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
						if (student is (name: var name, age: &gt;= 18))
						{
						    Console.WriteLine(name);
						}
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="M:OneOf.OneOfExtensions.Deconstruct``4(OneOf.OneOf{``0,``1,``2,``3},System.Boolean@,System.Boolean@,System.Boolean@,System.Boolean@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
						public static void Deconstruct(out string name, out int age)
						{
						    name = Name;
						    age = Age;
						}
						</code>
						The following code will be legal.
						<code>
						// Use explicitly typed variables to get a deconstruction.
						(string name, int age) = student;

						// Or use the type inferring to omit the type of each variable having been deconstructed.
						var (name, age) = student;

						// Of course, you can also use the invocation to get values.
						student.Deconstruct(out string name, out int age);
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
						if (student is (name: var name, age: &gt;= 18))
						{
						    Console.WriteLine(name);
						}
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="T:Program">
            <summary>
            The program class, the provider of entry point.
            </summary>
        </member>
        <member name="F:Program.KnownColors">
            <summary>
            The table of known colors.
            </summary>
        </member>
        <member name="F:Program.KnownKinds">
            <summary>
            The table of known kinds.
            </summary>
        </member>
    </members>
</doc>
