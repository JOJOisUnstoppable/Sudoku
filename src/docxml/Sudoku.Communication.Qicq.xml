<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Sudoku.Communication.Qicq</name>
    </assembly>
    <members>
        <member name="T:Sudoku.Communication.Qicq.AppLifecycle.EnvironmentData">
            <summary>
            Provides with environment data.
            </summary>
        </member>
        <member name="F:Sudoku.Communication.Qicq.AppLifecycle.EnvironmentData.Rng">
            <summary>
            The random number generator.
            </summary>
        </member>
        <member name="F:Sudoku.Communication.Qicq.AppLifecycle.EnvironmentData.EnvironmentCommandExecuting">
            <summary>
            The current executing command.
            </summary>
        </member>
        <member name="F:Sudoku.Communication.Qicq.AppLifecycle.EnvironmentData.Puzzle">
            <summary>
            The puzzle.
            </summary>
        </member>
        <member name="F:Sudoku.Communication.Qicq.AppLifecycle.EnvironmentData.Painter">
            <summary>
            The painter.
            </summary>
        </member>
        <member name="T:Sudoku.Communication.Qicq.CommandComparison">
            <summary>
            Represents a comparison type that compares for two commands, using key value (<see cref="T:System.String"/> values).
            </summary>
        </member>
        <member name="F:Sudoku.Communication.Qicq.CommandComparison.Strict">
            <summary>
            Indicates the comparison type is struct. Two commands should compare their <see cref="T:System.String"/> value.
            They are same if and only if they holds a same <see cref="T:System.String"/> value.
            </summary>
        </member>
        <member name="F:Sudoku.Communication.Qicq.CommandComparison.Prefix">
            <summary>
            Indicates the comparison type is comparing as prefixes. If the target <see cref="T:System.String"/> starts with the specified value,
            the comparison will be determined as <see langword="true"/>.
            </summary>
        </member>
        <member name="T:Sudoku.Communication.Qicq.Commands.CheckInCommand">
            <summary>
            Indicates the check-in command.
            </summary>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Commands.CheckInCommand.CommandName">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Commands.CheckInCommand.ComparisonMode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Communication.Qicq.Commands.CheckInCommand.ExecuteCoreAsync(System.String,Mirai.Net.Data.Messages.Receivers.GroupMessageReceiver)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Communication.Qicq.Commands.ClearCommand">
            <summary>
            Indicates the clear command.
            </summary>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Commands.ClearCommand.CommandName">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Commands.ClearCommand.EnvironmentCommand">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Commands.ClearCommand.ComparisonMode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Communication.Qicq.Commands.ClearCommand.ExecuteCoreAsync(System.String,Mirai.Net.Data.Messages.Receivers.GroupMessageReceiver)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Communication.Qicq.Commands.Command">
            <summary>
            Defines a command.
            </summary>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Commands.Command.CommandName">
            <summary>
            Indicates the command name that will be used as comparison.
            </summary>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Commands.Command.EnvironmentCommand">
            <summary>
            Indicates the environment command that the current command relies on.
            </summary>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Commands.Command.Prefixes">
            <summary>
            Indicates the prefix.
            </summary>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Commands.Command.ComparisonMode">
            <summary>
            Indicates the comparison mode that will be used as check commands.
            </summary>
        </member>
        <member name="M:Sudoku.Communication.Qicq.Commands.Command.ExecuteAsync(System.String,Mirai.Net.Data.Messages.Receivers.GroupMessageReceiver)">
            <summary>
            Execute the command.
            </summary>
            <param name="args">The arguments.</param>
            <param name="e">The event arguments.</param>
            <returns>
            Returns a task instance that returns a <see cref="T:System.Boolean"/> value indicating whether the operation executed successfully.
            </returns>
        </member>
        <member name="M:Sudoku.Communication.Qicq.Commands.Command.ExecuteCoreAsync(System.String,Mirai.Net.Data.Messages.Receivers.GroupMessageReceiver)">
            <inheritdoc cref="M:Sudoku.Communication.Qicq.Commands.Command.ExecuteAsync(System.String,Mirai.Net.Data.Messages.Receivers.GroupMessageReceiver)"/>
        </member>
        <member name="T:Sudoku.Communication.Qicq.Commands.CommandAttribute">
            <summary>
            Declares the command and its permission.
            </summary>
        </member>
        <member name="M:Sudoku.Communication.Qicq.Commands.CommandAttribute.#ctor">
            <summary>
            Initializes a <see cref="T:Sudoku.Communication.Qicq.Commands.CommandAttribute"/> instance.
            </summary>
        </member>
        <member name="M:Sudoku.Communication.Qicq.Commands.CommandAttribute.#ctor(Mirai.Net.Data.Shared.Permissions[])">
            <summary>
            Initializes a <see cref="T:Sudoku.Communication.Qicq.Commands.CommandAttribute"/> instance.
            </summary>
            <param name="permission">The permission.</param>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Commands.CommandAttribute.AllowedPermissions">
            <summary>
            Indicates the permission.
            </summary>
        </member>
        <member name="T:Sudoku.Communication.Qicq.Commands.ComplexLookupScoreCommand">
            <summary>
            Indicates the complex lookup score command.
            </summary>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Commands.ComplexLookupScoreCommand.CommandName">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Commands.ComplexLookupScoreCommand.ComparisonMode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Communication.Qicq.Commands.ComplexLookupScoreCommand.ExecuteCoreAsync(System.String,Mirai.Net.Data.Messages.Receivers.GroupMessageReceiver)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Communication.Qicq.Commands.DeleteDigitCommand">
            <summary>
            Indicates the delete command.
            </summary>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Commands.DeleteDigitCommand.CommandName">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Commands.DeleteDigitCommand.EnvironmentCommand">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Commands.DeleteDigitCommand.ComparisonMode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Communication.Qicq.Commands.DeleteDigitCommand.ExecuteCoreAsync(System.String,Mirai.Net.Data.Messages.Receivers.GroupMessageReceiver)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Communication.Qicq.Commands.DrawCommand">
            <summary>
            Indicates draw command.
            </summary>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Commands.DrawCommand.CommandName">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Commands.DrawCommand.EnvironmentCommand">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Commands.DrawCommand.ComparisonMode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Communication.Qicq.Commands.DrawCommand.ExecuteCoreAsync(System.String,Mirai.Net.Data.Messages.Receivers.GroupMessageReceiver)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Communication.Qicq.Commands.DrawEndCommand">
            <summary>
            Indicates the draw end command.
            </summary>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Commands.DrawEndCommand.CommandName">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Commands.DrawEndCommand.EnvironmentCommand">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Commands.DrawEndCommand.ComparisonMode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Communication.Qicq.Commands.DrawEndCommand.ExecuteCoreAsync(System.String,Mirai.Net.Data.Messages.Receivers.GroupMessageReceiver)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Communication.Qicq.Commands.DrawStartCommand">
            <summary>
            Indicates the draw start command.
            </summary>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Commands.DrawStartCommand.CommandName">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Commands.DrawStartCommand.ComparisonMode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Communication.Qicq.Commands.DrawStartCommand.ExecuteCoreAsync(System.String,Mirai.Net.Data.Messages.Receivers.GroupMessageReceiver)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Communication.Qicq.Commands.HelpCommand">
            <summary>
            Indicates the help command.
            </summary>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Commands.HelpCommand.CommandName">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Commands.HelpCommand.ComparisonMode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Communication.Qicq.Commands.HelpCommand.ExecuteCoreAsync(System.String,Mirai.Net.Data.Messages.Receivers.GroupMessageReceiver)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Communication.Qicq.Commands.ICommandDataProvider">
            <summary>
            Extracts a type that creates data used by commands.
            </summary>
        </member>
        <member name="F:Sudoku.Communication.Qicq.Commands.ICommandDataProvider.KnownColors">
            <summary>
            The table of known colors.
            </summary>
        </member>
        <member name="F:Sudoku.Communication.Qicq.Commands.ICommandDataProvider.KnownKinds">
            <summary>
            The table of known kinds.
            </summary>
        </member>
        <member name="M:Sudoku.Communication.Qicq.Commands.ICommandDataProvider.GetIdentifier(System.String)">
            <summary>
            Try to fetch the identifier name via the color name.
            </summary>
            <param name="name">The name of the color.</param>
            <returns>The identifier instance.</returns>
        </member>
        <member name="M:Sudoku.Communication.Qicq.Commands.ICommandDataProvider.GetCoordinate(System.String)">
            <summary>
            Try to fetch the coordinate value.
            </summary>
            <param name="rawCoordinate">The coordinate string value.</param>
            <returns>
            Returns a value that can be <see cref="T:Sudoku.Concepts.CellMap"/>, <see cref="T:Sudoku.Concepts.Candidates"/> and <see cref="T:System.Int32"/> value, where:
            <list type="table">
            <item>
            <term><see cref="T:Sudoku.Concepts.CellMap"/></term>
            <description>The cells parsed if the string value can be parsed as <see cref="T:Sudoku.Concepts.CellMap"/>.</description>
            </item>
            <item>
            <term><see cref="T:Sudoku.Concepts.Candidates"/></term>
            <description>The candidates parsed if the string value can be parsed as <see cref="T:Sudoku.Concepts.Candidates"/>.</description>
            </item>
            <item>
            <term><see cref="T:System.Int32"/></term>
            <description>The house parsed if the string value can be parsed as house index.</description>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Sudoku.Communication.Qicq.Commands.ICommandDataProvider.GetCell(System.String)">
            <summary>
            Try to fetch the coordinate value.
            </summary>
            <param name="rawCoordinate">The coordinate string value.</param>
            <returns>The cell index parsed. If failed to be parsed, <see langword="null"/> will be returned.</returns>
        </member>
        <member name="M:Sudoku.Communication.Qicq.Commands.ICommandDataProvider.GenerateOriginalValueEarned">
            <summary>
            Generates a value that describes the experience point that the current user can be earned.
            </summary>
            <returns>The value.</returns>
        </member>
        <member name="M:Sudoku.Communication.Qicq.Commands.ICommandDataProvider.GenerateValueEarned(System.Int32)">
            <summary>
            Generates a value that describes the experience point that the current user can be earned.
            </summary>
            <param name="continuousDaysCount">The number of continuous days that the user has already been checking-in.</param>
            <returns>The value.</returns>
        </member>
        <member name="T:Sudoku.Communication.Qicq.Commands.LookupScoreCommand">
            <summary>
            The lookup score command.
            </summary>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Commands.LookupScoreCommand.CommandName">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Commands.LookupScoreCommand.ComparisonMode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Communication.Qicq.Commands.LookupScoreCommand.ExecuteCoreAsync(System.String,Mirai.Net.Data.Messages.Receivers.GroupMessageReceiver)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Communication.Qicq.Commands.RankingCommand">
            <summary>
            Indicates the ranking command.
            </summary>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Commands.RankingCommand.CommandName">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Commands.RankingCommand.ComparisonMode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Communication.Qicq.Commands.RankingCommand.ExecuteCoreAsync(System.String,Mirai.Net.Data.Messages.Receivers.GroupMessageReceiver)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Communication.Qicq.Commands.SetDigitCommand">
            <summary>
            Indicates the set digit command.
            </summary>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Commands.SetDigitCommand.CommandName">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Commands.SetDigitCommand.EnvironmentCommand">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Commands.SetDigitCommand.ComparisonMode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Communication.Qicq.Commands.SetDigitCommand.ExecuteCoreAsync(System.String,Mirai.Net.Data.Messages.Receivers.GroupMessageReceiver)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Communication.Qicq.Commands.UpdateScoreCommand">
            <summary>
            Indicates the update score command.
            </summary>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Commands.UpdateScoreCommand.CommandName">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Commands.UpdateScoreCommand.ComparisonMode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Communication.Qicq.Commands.UpdateScoreCommand.ExecuteCoreAsync(System.String,Mirai.Net.Data.Messages.Receivers.GroupMessageReceiver)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Communication.Qicq.Models.UserData">
            <summary>
            Defines a user data.
            </summary>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Models.UserData.QQ">
            <summary>
            The user's QQ number.
            </summary>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Models.UserData.Score">
            <summary>
            Indicates the user's score.
            </summary>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Models.UserData.ComboCheckedIn">
            <summary>
            Indicates the number of continuous days that the user has checked in.
            </summary>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Models.UserData.LastCheckIn">
            <summary>
            Indicates the last time checked in of the current user.
            </summary>
        </member>
        <member name="T:Sudoku.Communication.Qicq.Strings.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Strings.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Strings.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Strings.Resources.AdminQQ">
            <summary>
              Looks up a localized string similar to 747507738.
            </summary>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Strings.Resources.BotQQ">
            <summary>
              Looks up a localized string similar to 979329690.
            </summary>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Strings.Resources.BotSettingsFolderName">
            <summary>
              Looks up a localized string similar to BotData.
            </summary>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Strings.Resources.CachedPictureFolderName">
            <summary>
              Looks up a localized string similar to TempPictures.
            </summary>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Strings.Resources.HostPort">
            <summary>
              Looks up a localized string similar to localhost:8080.
            </summary>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Strings.Resources.SudokuGroupQQ">
            <summary>
              Looks up a localized string similar to 924849321.
            </summary>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Strings.Resources.UserSettingsFolderName">
            <summary>
              Looks up a localized string similar to Users.
            </summary>
        </member>
        <member name="P:Sudoku.Communication.Qicq.Strings.Resources.VerifyKey">
            <summary>
              Looks up a localized string similar to helloworld.
            </summary>
        </member>
        <member name="T:Mirai.Net.Data.Shared.GroupExtensions">
            <summary>
            Provides with extension methods on <see cref="T:Mirai.Net.Data.Shared.Group"/>.
            </summary>
            <seealso cref="T:Mirai.Net.Data.Shared.Group"/>
        </member>
        <member name="M:Mirai.Net.Data.Shared.GroupExtensions.GetMemberAsync(Mirai.Net.Data.Shared.Group,System.String)">
            <summary>
            Gets the member whose QQ or name is specified one.
            </summary>
            <param name="this">The group.</param>
            <param name="nameOrId">The QQ number or target member's name.</param>
            <returns>The target member returned. If none found, <see langword="null"/>.</returns>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Mirai.Net.Data.Shared.GroupExtensions.GetMemberFromQQAsync(Mirai.Net.Data.Shared.Group,System.String)">
            <summary>
            Gets the member whose QQ number is the specified one.
            </summary>
            <param name="this">The group.</param>
            <param name="qq">The QQ number.</param>
            <returns>The target member returned. If none found, <see langword="null"/>.</returns>
        </member>
        <member name="T:Mirai.Net.Data.Messages.MessageChainExtensions">
            <summary>
            Provides with extension methods on <see cref="T:Mirai.Net.Data.Messages.MessageChain"/>.
            </summary>
            <seealso cref="T:Mirai.Net.Data.Messages.MessageChain"/>
        </member>
        <member name="M:Mirai.Net.Data.Messages.MessageChainExtensions.Deconstruct(Mirai.Net.Data.Messages.MessageChain,System.String@,System.String@,System.String[]@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
						public static void Deconstruct(out string name, out int age)
						{
						    name = Name;
						    age = Age;
						}
						</code>
						The following code will be legal.
						<code>
						// Use explicitly typed variables to get a deconstruction.
						(string name, int age) = student;

						// Or use the type inferring to omit the type of each variable having been deconstructed.
						var (name, age) = student;

						// Of course, you can also use the invocation to get values.
						student.Deconstruct(out string name, out int age);
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
						if (student is (name: var name, age: &gt;= 18))
						{
						    Console.WriteLine(name);
						}
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="T:Mirai.Net.Sessions.MiraiBotSubscribingExtensions">
            <summary>
            Provides with extenions methods on subscribing events for a <see cref="T:Mirai.Net.Sessions.MiraiBot"/> instance.
            </summary>
        </member>
        <member name="T:OneOf.OneOfExtensions">
            <summary>
            Provides extension methods on <see cref="N:OneOf"/> types.
            </summary>
            <seealso cref="N:OneOf"/>
        </member>
        <member name="M:OneOf.OneOfExtensions.Deconstruct``2(OneOf.OneOf{``0,``1},System.Boolean@,System.Boolean@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
						public static void Deconstruct(out string name, out int age)
						{
						    name = Name;
						    age = Age;
						}
						</code>
						The following code will be legal.
						<code>
						// Use explicitly typed variables to get a deconstruction.
						(string name, int age) = student;

						// Or use the type inferring to omit the type of each variable having been deconstructed.
						var (name, age) = student;

						// Of course, you can also use the invocation to get values.
						student.Deconstruct(out string name, out int age);
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
						if (student is (name: var name, age: &gt;= 18))
						{
						    Console.WriteLine(name);
						}
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="M:OneOf.OneOfExtensions.Deconstruct``3(OneOf.OneOf{``0,``1,``2},System.Boolean@,System.Boolean@,System.Boolean@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
						public static void Deconstruct(out string name, out int age)
						{
						    name = Name;
						    age = Age;
						}
						</code>
						The following code will be legal.
						<code>
						// Use explicitly typed variables to get a deconstruction.
						(string name, int age) = student;

						// Or use the type inferring to omit the type of each variable having been deconstructed.
						var (name, age) = student;

						// Of course, you can also use the invocation to get values.
						student.Deconstruct(out string name, out int age);
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
						if (student is (name: var name, age: &gt;= 18))
						{
						    Console.WriteLine(name);
						}
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="M:OneOf.OneOfExtensions.Deconstruct``4(OneOf.OneOf{``0,``1,``2,``3},System.Boolean@,System.Boolean@,System.Boolean@,System.Boolean@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
						public static void Deconstruct(out string name, out int age)
						{
						    name = Name;
						    age = Age;
						}
						</code>
						The following code will be legal.
						<code>
						// Use explicitly typed variables to get a deconstruction.
						(string name, int age) = student;

						// Or use the type inferring to omit the type of each variable having been deconstructed.
						var (name, age) = student;

						// Of course, you can also use the invocation to get values.
						student.Deconstruct(out string name, out int age);
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
						if (student is (name: var name, age: &gt;= 18))
						{
						    Console.WriteLine(name);
						}
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="T:Program">
            <summary>
            The program type.
            </summary>
        </member>
        <member name="M:Program.BilibiliPattern">
            <remarks>
            Pattern explanation:<br/>
            <code>
            ○ 1st capture group.<br/>
                ○ Match with 2 alternative expressions, atomically.<br/>
                    ○ Match a sequence of expressions.<br/>
                        ○ 2nd capture group.<br/>
                            ○ Match the string "哔哩".<br/>
                        ○ Match the same text as matched by the 2nd capture group.<br/>
                    ○ Match a sequence of expressions.<br/>
                        ○ Match a character in the set [Bb].<br/>
                        ○ Match with 2 alternative expressions, atomically.<br/>
                            ○ Match a sequence of expressions.<br/>
                                ○ Match a whitespace character atomically at most 3 times.<br/>
                                ○ Match '站'.<br/>
                            ○ Match a sequence of expressions.<br/>
                                ○ Match 'i'.<br/>
                                ○ 3rd capture group.<br/>
                                    ○ Match the string "li".<br/>
                                ○ Match the string "bi".<br/>
                                ○ Match the same text as matched by the 3rd capture group.<br/>
            </code>
            </remarks>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.BilibiliPattern_0">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the BilibiliPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.BilibiliPattern_0.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.BilibiliPattern_0.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.BilibiliPattern_0.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.BilibiliPattern_0.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.BilibiliPattern_0.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.BilibiliPattern_0.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.BilibiliPattern_0.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.BilibiliPattern_0.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
    </members>
</doc>
