<?xml version="1.0"?>
<doc>
    <assembly>
        <name>SystemExtensions</name>
    </assembly>
    <members>
        <member name="T:System.Algorithms">
            <summary>
            Provides all algorithm processing methods.
            </summary>
        </member>
        <member name="M:System.Algorithms.Sort``1(``0[],)">
            <summary>
            Sort the specified array by quick sort.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="this">The array.</param>
            <param name="comparer">The method to compare two elements.</param>
            <remarks>
            If you want to use this method, please note that the <typeparamref name="T"/>
            may not be the built-in types such as <see cref="T:System.Int32"/>, <see cref="T:System.Single"/> or so on,
            because they can use operators directly.
            </remarks>
        </member>
        <member name="M:System.Algorithms.GetSubsets``1(System.Collections.Generic.IReadOnlyList{``0})">
            <summary>
            Get all subsets that each element is chosen at most once.
            Note that the null set <c>{ }</c> doesn't belong to the result.
            </summary>
            <param name="this">The array of elements.</param>
            <returns>
            The subsets of the list. For example, if the input array is <c>{ 1, 2, 3 }</c>, the output
            should be as follows:
            <list type="table">
            <item><c>{ 1 }</c></item>
            <item><c>{ 2 }</c></item>
            <item><c>{ 3 }</c></item>
            <item><c>{ 1, 2 }</c></item>
            <item><c>{ 1, 3 }</c></item>
            <item><c>{ 2, 3 }</c></item>
            <item><c>{ 1, 2, 3 }</c></item>
            </list>
            7 cases (without null set) in total.
            </returns>
        </member>
        <member name="M:System.Algorithms.GetSubsets``1(System.Collections.Generic.IReadOnlyList{``0},System.Int32)">
            <summary>
            Get all subsets from the specified number of the values to take.
            </summary>
            <param name="this">The array.</param>
            <param name="count">The number of elements you want to take.</param>
            <returns>
            The subsets of the list. For example, if the input array is <c>{ 1, 2, 3 }</c> and
            the argument <paramref name="count"/> is 2, the output should be as follows:
            <list type="table">
            <item><c>{ 1, 2 }</c>,</item>
            <item><c>{ 1, 3 }</c>,</item>
            <item><c>{ 2, 3 }</c></item>
            </list>
            3 cases in total.
            </returns>
        </member>
        <member name="M:System.Algorithms.GetExtractedCombinations(System.Int32[][])">
            <summary>
            Get all combinations that each sub-array only choose one.
            </summary>
            <param name="this">The jigsaw array.</param>
            <returns>
            All combinations that each sub-array choose one. For example, if the array is
            <c>{ { 1, 2, 3 }, { 1, 3 }, { 1, 4, 7, 10 } }</c>, all combinations are:
            <list type="table">
            <item><c>{ 1, 1, 1 }</c>, <c>{ 1, 1, 4 }</c>, <c>{ 1, 1, 7 }</c>, <c>{ 1, 1, 10 }</c>,</item>
            <item><c>{ 1, 3, 1 }</c>, <c>{ 1, 3, 4 }</c>, <c>{ 1, 3, 7 }</c>, <c>{ 1, 3, 10 }</c>,</item>
            <item><c>{ 2, 1, 1 }</c>, <c>{ 2, 1, 4 }</c>, <c>{ 2, 1, 7 }</c>, <c>{ 2, 1, 10 }</c>,</item>
            <item><c>{ 2, 3, 1 }</c>, <c>{ 2, 3, 4 }</c>, <c>{ 2, 3, 7 }</c>, <c>{ 2, 3, 10 }</c>,</item>
            <item><c>{ 3, 1, 1 }</c>, <c>{ 3, 1, 4 }</c>, <c>{ 3, 1, 7 }</c>, <c>{ 3, 1, 10 }</c>,</item>
            <item><c>{ 3, 3, 1 }</c>, <c>{ 3, 3, 4 }</c>, <c>{ 3, 3, 7 }</c>, <c>{ 3, 3, 10 }</c></item>
            </list>
            24 cases in total.
            </returns>
            <remarks>
            Please note that each return values unit (an array) contains the same number of elements
            with the whole array.
            </remarks>
        </member>
        <member name="T:System.Collections.Generic.InsertionBehavior">
            <summary>
            Used internally to control behavior of insertion into a <see cref="T:System.Collections.Generic.ValueDictionary`2"/>.
            </summary>
        </member>
        <member name="F:System.Collections.Generic.InsertionBehavior.None">
            <summary>
            The default insertion behavior.
            </summary>
        </member>
        <member name="F:System.Collections.Generic.InsertionBehavior.OverwriteExisting">
            <summary>
            Specifies that an existing entry with the same key should be overwritten if encountered.
            </summary>
        </member>
        <member name="F:System.Collections.Generic.InsertionBehavior.ThrowOnExisting">
            <summary>
            Specifies that if an existing entry with the same key is encountered, an exception should be thrown.
            </summary>
        </member>
        <member name="T:System.Collections.Generic.NotifyChangedList`1">
            <summary>
            Encapsulates the list that notifies the users while adding an element.
            </summary>
            <typeparam name="T">The type of the element.</typeparam>
        </member>
        <member name="F:System.Collections.Generic.NotifyChangedList`1._innerList">
            <summary>
            Indicates the inner list.
            </summary>
        </member>
        <member name="P:System.Collections.Generic.NotifyChangedList`1.Count">
            <inheritdoc/>
        </member>
        <member name="P:System.Collections.Generic.NotifyChangedList`1.IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="P:System.Collections.Generic.NotifyChangedList`1.Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="E:System.Collections.Generic.NotifyChangedList`1.ElementAdded">
            <summary>
            Indicates the event triggers when the element is added.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.NotifyChangedList`1.Add(`0)">
            <inheritdoc/>
        </member>
        <member name="M:System.Collections.Generic.NotifyChangedList`1.Clear">
            <inheritdoc/>
        </member>
        <member name="M:System.Collections.Generic.NotifyChangedList`1.Contains(`0)">
            <inheritdoc/>
        </member>
        <member name="M:System.Collections.Generic.NotifyChangedList`1.CopyTo(`0[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:System.Collections.Generic.NotifyChangedList`1.IndexOf(`0)">
            <inheritdoc/>
        </member>
        <member name="M:System.Collections.Generic.NotifyChangedList`1.Insert(System.Int32,`0)">
            <inheritdoc/>
        </member>
        <member name="M:System.Collections.Generic.NotifyChangedList`1.Remove(`0)">
            <inheritdoc/>
        </member>
        <member name="M:System.Collections.Generic.NotifyChangedList`1.RemoveAt(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:System.Collections.Generic.Set`1">
            <summary>
            Indicates a set which contains the different elements.
            </summary>
            <typeparam name="TEquatable">The type of the element.</typeparam>
        </member>
        <member name="F:System.Collections.Generic.Set`1._list">
            <summary>
            The inner list.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.Set`1.#ctor">
            <summary>
            Initializes a default <see cref="T:System.Collections.Generic.Set`1"/> collection instance,
            with no elements in it.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.Set`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add a series of elements.
            </summary>
            <param name="elements">The elements.</param>
        </member>
        <member name="P:System.Collections.Generic.Set`1.Count">
            <summary>
            The number of elements.
            </summary>
        </member>
        <member name="P:System.Collections.Generic.Set`1.System#Collections#Generic#ICollection{TEquatable}#IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="P:System.Collections.Generic.Set`1.Item(`0)">
            <summary>
            Get the first element that is equal to the specified parameter.
            </summary>
            <param name="element">The element.</param>
            <returns>The first element to satisfy the condition.</returns>
        </member>
        <member name="M:System.Collections.Generic.Set`1.Clear">
            <inheritdoc/>
        </member>
        <member name="M:System.Collections.Generic.Set`1.CopyTo(`0[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:System.Collections.Generic.Set`1.Sort">
            <summary>
            Sort the list.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.Set`1.Sort(System.Comparison{`0})">
            <summary>
            Sort the list with the specified comparison.
            </summary>
            <param name="comparison">The comparison.</param>
        </member>
        <member name="M:System.Collections.Generic.Set`1.Add(`0)">
            <summary>
            Add an element into the set.
            </summary>
            <param name="item">The item.</param>
        </member>
        <member name="M:System.Collections.Generic.Set`1.TryGetValue(`0,`0@)">
            <summary>
            Get the instance in the collection that is same (or similar) as another one
            specified as the parameter.
            </summary>
            <param name="other">The value to compare.</param>
            <param name="result">The result.</param>
            <returns>Indicates whether the searching is successful.</returns>
            <remarks>
            Note that <paramref name="other"/> and <paramref name="result"/> aren't totally same.
            The comparison is decided by the implementation of its <c>Equals</c> method.
            </remarks>
        </member>
        <member name="M:System.Collections.Generic.Set`1.Remove">
            <summary>
            Remove the last element out of the list.
            </summary>
            <returns>The element removed.</returns>
        </member>
        <member name="M:System.Collections.Generic.Set`1.RemoveAt(System.Int32)">
            <summary>
            Remove the element at the specified index.
            </summary>
            <param name="index">The index.</param>
            <returns>The element removed.</returns>
        </member>
        <member name="M:System.Collections.Generic.Set`1.RemoveAt(System.Index@)">
            <summary>
            Remove the element at the specified index.
            </summary>
            <param name="index">The index.</param>
            <returns>The element removed.</returns>
        </member>
        <member name="M:System.Collections.Generic.Set`1.Contains(`0)">
            <inheritdoc/>
        </member>
        <member name="M:System.Collections.Generic.Set`1.Remove(`0)">
            <inheritdoc/>
        </member>
        <member name="M:System.Collections.Generic.Set`1.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:System.Collections.Generic.Set`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc/>
        </member>
        <member name="M:System.Collections.Generic.Set`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc/>
        </member>
        <member name="M:System.Collections.Generic.Set`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc/>
        </member>
        <member name="M:System.Collections.Generic.Set`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc/>
        </member>
        <member name="M:System.Collections.Generic.Set`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc/>
        </member>
        <member name="M:System.Collections.Generic.Set`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc/>
        </member>
        <member name="M:System.Collections.Generic.Set`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc/>
        </member>
        <member name="M:System.Collections.Generic.Set`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc/>
        </member>
        <member name="M:System.Collections.Generic.Set`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc/>
        </member>
        <member name="M:System.Collections.Generic.Set`1.UnionWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc/>
        </member>
        <member name="M:System.Collections.Generic.Set`1.ToString">
            <inheritdoc/>
        </member>
        <member name="M:System.Collections.Generic.Set`1.System#Collections#Generic#ICollection{TEquatable}#Add(`0)">
            <inheritdoc/>
        </member>
        <member name="M:System.Collections.Generic.Set`1.InternalEquals(System.Collections.Generic.Set{`0},System.Collections.Generic.Set{`0})">
            <summary>
            The internal equality determination.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:System.Collections.Generic.Set`1.SetEquals(System.Collections.Generic.Set{`0},System.Collections.Generic.Set{`0})">
            <summary>
            Determine whether two <see cref="T:System.Collections.Generic.Set`1"/>s contain the same elements.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:System.Collections.Generic.Set`1.op_BitwiseAnd(System.Collections.Generic.Set{`0},System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Calls the method <see cref="M:System.Collections.Generic.Set`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})"/>, and returns the
            reference of the <paramref name="left"/> parameter.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>The intersection result.</returns>
            <seealso cref="M:System.Collections.Generic.Set`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:System.Collections.Generic.Set`1.op_BitwiseOr(System.Collections.Generic.Set{`0},System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Calls the method <see cref="M:System.Collections.Generic.Set`1.UnionWith(System.Collections.Generic.IEnumerable{`0})"/>, and returns the
            reference of the <paramref name="left"/> parameter.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>The union result.</returns>
            <seealso cref="M:System.Collections.Generic.Set`1.UnionWith(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:System.Collections.Generic.Set`1.op_ExclusiveOr(System.Collections.Generic.Set{`0},System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Calls the method <see cref="M:System.Collections.Generic.Set`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})"/>, and returns the
            reference of the <paramref name="left"/> parameter.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>The symmetric exception result.</returns>
            <seealso cref="M:System.Collections.Generic.Set`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:System.Collections.Generic.Set`1.op_Subtraction(System.Collections.Generic.Set{`0},System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Calls the method <see cref="M:System.Collections.Generic.Set`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})"/>, and returns the
            reference of the <paramref name="left"/> parameter.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>The exception result.</returns>
            <seealso cref="M:System.Collections.Generic.Set`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="T:System.Collections.Generic.TreeNode`1">
            <summary>
            Encapsulates a tree node.
            </summary>
            <typeparam name="T">The type of the element.</typeparam>
        </member>
        <member name="P:System.Collections.Generic.TreeNode`1.Id">
            <summary>
            Indicates the current ID.
            </summary>
        </member>
        <member name="P:System.Collections.Generic.TreeNode`1.ParentId">
            <summary>
            Indicates the parent ID of this instance.
            </summary>
        </member>
        <member name="P:System.Collections.Generic.TreeNode`1.IsLeaf">
            <summary>
            Indicates whether the current node is the left node.
            </summary>
        </member>
        <member name="P:System.Collections.Generic.TreeNode`1.Content">
            <summary>
            Indicates the content.
            </summary>
        </member>
        <member name="P:System.Collections.Generic.TreeNode`1.Children">
            <summary>
            Indicates its children nodes.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.TreeNode`1.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:System.Collections.Generic.TreeNode`1.Equals(System.Collections.Generic.TreeNode{`0})">
            <inheritdoc/>
        </member>
        <member name="M:System.Collections.Generic.TreeNode`1.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:System.Collections.Generic.TreeNode`1.CompareTo(System.Collections.Generic.TreeNode{`0})">
            <inheritdoc/>
        </member>
        <member name="M:System.Collections.Generic.TreeNode`1.ToString">
            <inheritdoc/>
        </member>
        <member name="M:System.Collections.Generic.TreeNode`1.InternalCompare(System.Collections.Generic.TreeNode{`0},System.Collections.Generic.TreeNode{`0})">
            <summary>
            The internal comparison.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:System.Collections.Generic.TreeNode`1.op_Equality(System.Collections.Generic.TreeNode{`0},System.Collections.Generic.TreeNode{`0})">
            <summary>
            Determines whether two <see cref="T:System.Collections.Generic.TreeNode`1"/> instances hold a same inner value.
            </summary>
            <param name="left">The first instance to compare.</param>
            <param name="right">The second instance to compare.</param>
            <returns>A <see cref="T:System.Boolean"/> value.</returns>
        </member>
        <member name="M:System.Collections.Generic.TreeNode`1.op_Inequality(System.Collections.Generic.TreeNode{`0},System.Collections.Generic.TreeNode{`0})">
            <summary>
            Determines whether two <see cref="T:System.Collections.Generic.TreeNode`1"/> instances don't hold a same inner value.
            </summary>
            <param name="left">The first instance to compare.</param>
            <param name="right">The second instance to compare.</param>
            <returns>A <see cref="T:System.Boolean"/> value.</returns>
        </member>
        <member name="M:System.Collections.Generic.TreeNode`1.op_GreaterThan(System.Collections.Generic.TreeNode{`0},System.Collections.Generic.TreeNode{`0})">
            <summary>
            Determines whether the left <see cref="T:System.Collections.Generic.TreeNode`1"/> instance holds the greater <see cref="P:System.Collections.Generic.TreeNode`1.Id"/>
            value with the second <see cref="T:System.Collections.Generic.TreeNode`1"/> instance.
            </summary>
            <param name="left">The first instance to compare.</param>
            <param name="right">The second instace to compare.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
            <seealso cref="P:System.Collections.Generic.TreeNode`1.Id"/>
        </member>
        <member name="M:System.Collections.Generic.TreeNode`1.op_GreaterThanOrEqual(System.Collections.Generic.TreeNode{`0},System.Collections.Generic.TreeNode{`0})">
            <summary>
            Determines whether the left <see cref="T:System.Collections.Generic.TreeNode`1"/> instance holds the greater or same
            <see cref="P:System.Collections.Generic.TreeNode`1.Id"/> value with the second <see cref="T:System.Collections.Generic.TreeNode`1"/> instance.
            </summary>
            <param name="left">The first instance to compare.</param>
            <param name="right">The second instace to compare.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
            <seealso cref="P:System.Collections.Generic.TreeNode`1.Id"/>
        </member>
        <member name="M:System.Collections.Generic.TreeNode`1.op_LessThan(System.Collections.Generic.TreeNode{`0},System.Collections.Generic.TreeNode{`0})">
            <summary>
            Determines whether the left <see cref="T:System.Collections.Generic.TreeNode`1"/> instance holds the less
            <see cref="P:System.Collections.Generic.TreeNode`1.Id"/> value with the second <see cref="T:System.Collections.Generic.TreeNode`1"/> instance.
            </summary>
            <param name="left">The first instance to compare.</param>
            <param name="right">The second instace to compare.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
            <seealso cref="P:System.Collections.Generic.TreeNode`1.Id"/>
        </member>
        <member name="M:System.Collections.Generic.TreeNode`1.op_LessThanOrEqual(System.Collections.Generic.TreeNode{`0},System.Collections.Generic.TreeNode{`0})">
            <summary>
            Determines whether the left <see cref="T:System.Collections.Generic.TreeNode`1"/> instance holds the less or same
            <see cref="P:System.Collections.Generic.TreeNode`1.Id"/> value with the second <see cref="T:System.Collections.Generic.TreeNode`1"/> instance.
            </summary>
            <param name="left">The first instance to compare.</param>
            <param name="right">The second instace to compare.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
            <seealso cref="P:System.Collections.Generic.TreeNode`1.Id"/>
        </member>
        <member name="M:System.Collections.Generic.TreeNode`1.Deconstruct(System.Int32@,System.Int32@,System.Boolean@,`0@,System.Collections.Generic.ICollection{System.Collections.Generic.TreeNode{`0}}@)">
            <summary>
            Deconstruct the instance to multiple values, which allows you use the value tuple syntax
            to get the properties from an instance like:
            <code>
            var (variable1, variable2, variable3) = instance;
            </code>
            or like
            <code>
            (int variable1, double variable2, string? variable3) = instance;
            </code>
            </summary>
            <remarks>
            <para>
            The method should be declared manually when the type is a normal <see langword="struct"/>
            or <see langword="class"/>. If the method is in a <see langword="record"/>
            (or a <see langword="record struct"/>), the deconstruct method will be generated
            by the compiler automatically and returns <b>all properties</b>
            to those <see langword="out"/> parameters.
            </para>
            <para>
            Please note: If the deconstruct method is automatically generated by the compiler,
            you can't create a deconstruct method manually with the same number of the parameters
            than that auto method; otherwise, the method can't be called normally.
            </para>
            <para>
            In addition, the deconstruct methods can take <b>more than</b> 8 <see langword="out"/> parameters,
            although a normal <see cref="T:System.ValueTuple"/> can only contain at most 8 parameters.
            </para>
            </remarks>
            <seealso cref="T:System.ValueTuple"/>
        </member>
        <member name="T:System.Collections.Generic.ValueDictionary`2">
            <summary>
            Represents a collection of keys and values, which is similar with the type
            <see cref="T:System.Collections.Generic.Dictionary`2"/>. Different with that type, this type is represented as a
            <see langword="ref struct"/>, which means you can't use the instance of this type outside any methods
            as the data member of the types unless it's also a <see langword="ref struct"/>.
            </summary>
            <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
            <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
            <seealso cref="T:System.Collections.Generic.Dictionary`2"/>
        </member>
        <member name="T:System.Collections.Generic.ValueDictionary`2.CollectionsMarshalHelper">
            <summary>
            <para>
            A helper class containing APIs exposed through <see cref="T:System.Runtime.InteropServices.CollectionsMarshal"/>.
            </para>
            <para>
            These methods are relatively niche and only used in specific scenarios,
            so adding them in a separate type avoids the additional overhead on each
            <see cref="T:System.Collections.Generic.ValueDictionary`2"/> instantiation, especially in AOT scenarios.
            </para>
            </summary>
            <seealso cref="T:System.Runtime.InteropServices.CollectionsMarshal"/>
        </member>
        <member name="M:System.Collections.Generic.ValueDictionary`2.CollectionsMarshalHelper.GetValueRefOrAddDefault(System.Collections.Generic.ValueDictionary{`0,`1}@,`0,System.Boolean@)">
            <summary>
            Gets a ref to a <typeparamref name="TValue"/> in the <see cref="T:System.Collections.Generic.ValueDictionary`2"/>,
            adding a new entry with a default value if it does not exist in the <paramref name="dictionary"/>.
            </summary>
            <param name="dictionary">
            The dictionary to get the ref to <typeparamref name="TValue"/> from.
            </param>
            <param name="key">The key used for lookup.</param>
            <param name="exists">
            Whether or not a new entry for the given key was added to the dictionary.
            </param>
            <remarks>
            Items should not be added to or removed from the <see cref="T:System.Collections.Generic.ValueDictionary`2"/>
            while the ref <typeparamref name="TValue"/> is in use.
            </remarks>
        </member>
        <member name="F:System.Collections.Generic.ValueDictionary`2.StartOfFreeList">
            <summary>
            Indicates the free list start value.
            </summary>
        </member>
        <member name="F:System.Collections.Generic.ValueDictionary`2._count">
            <summary>
            The inner counting variable.
            </summary>
        </member>
        <member name="F:System.Collections.Generic.ValueDictionary`2._freeList">
            <summary>
            Indicates the free list.
            </summary>
        </member>
        <member name="F:System.Collections.Generic.ValueDictionary`2._freeCount">
            <summary>
            Indicates the free count.
            </summary>
        </member>
        <member name="F:System.Collections.Generic.ValueDictionary`2._version">
            <summary>
            Indicates how many times the instance being modified.
            </summary>
        </member>
        <member name="F:System.Collections.Generic.ValueDictionary`2._buckets">
            <summary>
            The buckets that stores the inner dictionary key informations.
            </summary>
        </member>
        <member name="F:System.Collections.Generic.ValueDictionary`2._fastModMultiplier">
            <summary>
            Indicates the fast modulo multiplier that is used for optimization the performance.
            </summary>
        </member>
        <member name="F:System.Collections.Generic.ValueDictionary`2._entries">
            <summary>
            All entries of the collection that stores the pair of key and value information.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.ValueDictionary`2.#ctor(System.Int32)">
            <summary>
            Initializes a <see cref="T:System.Collections.Generic.ValueDictionary`2"/> instance with the specified capacity.
            </summary>
            <param name="capacity">The capacity.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when the <paramref name="capacity"/> is a negative value.
            </exception>
        </member>
        <member name="P:System.Collections.Generic.ValueDictionary`2.Count">
            <summary>
            Indicates the number of elements stored in this collection.
            </summary>
        </member>
        <member name="P:System.Collections.Generic.ValueDictionary`2.Keys">
            <summary>
            Indicates the key collection.
            </summary>
        </member>
        <member name="P:System.Collections.Generic.ValueDictionary`2.Values">
            <summary>
            Indicates the value collection.
            </summary>
        </member>
        <member name="P:System.Collections.Generic.ValueDictionary`2.Item(`0)">
            <summary>
            Gets or sets the specified value from/into the collection.
            </summary>
            <param name="key">The key.</param>
            <value>The value you want to assign into.</value>
            <returns>The value of this key corresponded to.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Throws when the specified key doesn't found.</exception>
        </member>
        <member name="M:System.Collections.Generic.ValueDictionary`2.ContainsKey(`0)">
            <summary>
            Checks the collection, whether the collection contains the specified key.
            </summary>
            <param name="key">The key.</param>
            <returns>The <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:System.Collections.Generic.ValueDictionary`2.ContainsValue(`1)">
            <summary>
            Checks the collection, whether the collection contains the specified value.
            </summary>
            <param name="value">The value.</param>
            <returns>The <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:System.Collections.Generic.ValueDictionary`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            Copies the current collection into a new array of <see cref="T:System.Collections.Generic.KeyValuePair`2"/>s.
            </summary>
            <param name="array">The array of <see cref="T:System.Collections.Generic.KeyValuePair`2"/>s.</param>
            <param name="index">The index you want to copy as the start one.</param>
            <seealso cref="T:System.Collections.Generic.KeyValuePair`2"/>
            <exception cref="T:System.IndexOutOfRangeException">
            Throws when the specified argument <paramref name="index"/> is out of range.
            </exception>
            <exception cref="T:System.ArgumentException">Throws when the array is too small to store values.</exception>
        </member>
        <member name="M:System.Collections.Generic.ValueDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Try to get the value from the collection using the specified key as the entry point to visit that value.
            </summary>
            <param name="key">The key.</param>
            <param name="value">
            The value found. If the return value is <see langword="false"/>, the value will be
            <see langword="default"/>(<typeparamref name="TValue"/>).
            </param>
            <returns>The <see cref="T:System.Boolean"/> result indicating whether the finding operation is successful.</returns>
        </member>
        <member name="M:System.Collections.Generic.ValueDictionary`2.GetEnumerator">
            <summary>
            Gets the enumertor to iterate the collection.
            </summary>
            <returns>The enumerator.</returns>
        </member>
        <member name="M:System.Collections.Generic.ValueDictionary`2.GetBucket(System.UInt32)">
            <summary>
            Gets the bucket for using specified hash code.
            </summary>
            <param name="hashCode">The hash code.</param>
            <returns>
            The bucket result located. The return value is a <see langword="ref"/> <see cref="T:System.Int32"/> in order to
            help you use the value and re-assign the value.
            </returns>
        </member>
        <member name="M:System.Collections.Generic.ValueDictionary`2.FindValue(`0)">
            <summary>
            Finds the specified value, and returns the reference of the value in this collection, in order to
            allow you using <c><![CDATA[&FindValue(key)]]></c> syntax to get the pointer.
            </summary>
            <param name="key">The key.</param>
            <returns>
            The reference of the value. If don't found any satisfied result, the result will be the reference
            of <see langword="null"/>.
            </returns>
        </member>
        <member name="M:System.Collections.Generic.ValueDictionary`2.Add(`0,`1)">
            <summary>
            Add the specified key and value into the collection.
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:System.Collections.Generic.ValueDictionary`2.Clear">
            <summary>
            Clears the collection.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.ValueDictionary`2.Initialize(System.Int32)">
            <summary>
            Initializes the current collection as the specified capacity.
            </summary>
            <param name="capacity">The capacity.</param>
            <returns>The size of the collection.</returns>
        </member>
        <member name="M:System.Collections.Generic.ValueDictionary`2.TryInsert(`0,`1,System.Collections.Generic.InsertionBehavior)">
            <summary>
            Try to insert the specified key and the value into the collection using the specified behavior.
            </summary>
            <param name="key">The key to add.</param>
            <param name="value">The value to add.</param>
            <param name="behavior">The behavior.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating whether the operaion is successful.</returns>
        </member>
        <member name="M:System.Collections.Generic.ValueDictionary`2.Resize">
            <summary>
            Resizes the collection.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.ValueDictionary`2.Resize(System.Int32)">
            <summary>
            Resizes the collection with the specified size value and a <see cref="T:System.Boolean"/> value indicating
            whether the hash code will be re-calculated.
            </summary>
            <param name="newSize">The new size.</param>
        </member>
        <member name="M:System.Collections.Generic.ValueDictionary`2.Remove(`0)">
            <summary>
            Removes the value from the current collection using the specified key as the entry point
            to visit the corresponding value.
            </summary>
            <param name="key">The key</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating whether the operation is successful to remove.</returns>
        </member>
        <member name="M:System.Collections.Generic.ValueDictionary`2.Remove(`0,`1@)">
            <summary>
            Removes the element from the current collection using the specified key as the entry point
            to visit the corresponding value, and returns the value from the <see langword="out"/>
            parameter <paramref name="value"/>.
            </summary>
            <param name="key">The key to remove.</param>
            <param name="value">
            The value. If failed to remove, the value will be
            <see langword="default"/>(<typeparamref name="TValue"/>).
            </param>
            <returns>A <see cref="T:System.Boolean"/> result indicating whether the operation is successful to remove.</returns>
        </member>
        <member name="M:System.Collections.Generic.ValueDictionary`2.TryAdd(`0,`1)">
            <summary>
            Try to add the specified key and the value into the collection. If the collection contains the same
            key, the operation will be failed but don't throw exceptions.
            </summary>
            <param name="key">The key to add.</param>
            <param name="value">The value to add.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating whether the adding operation is successful.</returns>
        </member>
        <member name="M:System.Collections.Generic.ValueDictionary`2.EnsureCapacity(System.Int32)">
            <summary>
            Ensures that the dictionary can hold up to <paramref name="capacity"/> entries
            without any further expansion of its backing storage.
            </summary>
            <returns>The current capacity created.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when the argument <paramref name="capacity"/> is a negative value.
            </exception>
        </member>
        <member name="M:System.Collections.Generic.ValueDictionary`2.TrimExcess">
            <summary>
            Sets the capacity of this dictionary to what it would be if it had been originally
            initialized with all its entries.
            </summary>
            <remarks>
            <para>
            This method can be used to minimize the memory overhead
            once it is known that no new elements will be added.
            </para>
            <para>
            To allocate minimum size storage array, execute the following statements:
            <list type="bullet">
            <item><c>dictionary.Clear();</c></item>
            <item><c>dictionary.TrimExcess();</c></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:System.Collections.Generic.ValueDictionary`2.TrimExcess(System.Int32)">
            <summary>
            Sets the capacity of this dictionary to hold up <paramref name="capacity"/> entries
            without any further expansion of its backing storage.
            </summary>
            <remarks>
            This method can be used to minimize the memory overhead
            once it is known that no new elements will be added.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when <paramref name="capacity"/> is a negative value.
            </exception>
        </member>
        <member name="M:System.Collections.Generic.ValueDictionary`2.CopyEntries(System.Collections.Generic.ValueDictionary{`0,`1}.Entry[],System.Int32)">
            <summary>
            Copies all entries of this collection into the new array specified as the parameter.
            </summary>
            <param name="entries">The entries stores the copied entries.</param>
            <param name="count">The count you want to copy.</param>
        </member>
        <member name="M:System.Collections.Generic.ValueDictionary`2.UnsafeConvert``1(``0)">
            <summary>
            Converts the current value into an <see cref="T:System.Int32"/> value.
            </summary>
            <returns>The result value.</returns>
            <typeparam name="TUnmanaged">The type of the value.</typeparam>
        </member>
        <member name="T:System.Collections.Generic.ValueDictionary`2.Entry">
            <summary>
            Defines an entry of the dictionary.
            </summary>
        </member>
        <member name="F:System.Collections.Generic.ValueDictionary`2.Entry.HashCode">
            <summary>
            The hash code calculated.
            </summary>
        </member>
        <member name="F:System.Collections.Generic.ValueDictionary`2.Entry.NextValue">
            <summary>
            0-based index of next entry in chain. The possible values are:
            <list type="table">
            <listheader>
            <term>Value</term>
            <description>The description</description>
            </listheader>
            <item>
            <term>-1</term>
            <description>
            End of chain also encodes whether this entry <i>itself</i> is part of the free list
            by changing sign and subtracting 3.
            </description>
            </item>
            <item>
            <term>-2</term>
            <description>End of free list.</description>
            </item>
            <item>
            <term>-3</term>
            <description>Index 0 but on free list.</description>
            </item>
            <item>
            <term>-4</term>
            <description>Index 1 but on free list.</description>
            </item>
            </list>
            etc.
            </summary>
        </member>
        <member name="F:System.Collections.Generic.ValueDictionary`2.Entry.Key">
            <summary>
            The key of the entry.
            </summary>
        </member>
        <member name="F:System.Collections.Generic.ValueDictionary`2.Entry.Value">
            <summary>
            The value of the entry.
            </summary>
        </member>
        <member name="T:System.Collections.Generic.ValueDictionary`2.Enumerator">
            <summary>
            Indicates the inner enumerator of this collection.
            </summary>
        </member>
        <member name="F:System.Collections.Generic.ValueDictionary`2.Enumerator._dictionary">
            <summary>
            Indicates the dictionary instance.
            </summary>
        </member>
        <member name="F:System.Collections.Generic.ValueDictionary`2.Enumerator._version">
            <summary>
            Indicates the version modified.
            </summary>
        </member>
        <member name="F:System.Collections.Generic.ValueDictionary`2.Enumerator._index">
            <summary>
            Indicates the index.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.ValueDictionary`2.Enumerator.#ctor(System.Collections.Generic.ValueDictionary{`0,`1}@)">
            <summary>
            Initializes an instance with the specified dictionary.
            </summary>
            <param name="dictionary">The dictionary.</param>
        </member>
        <member name="M:System.Collections.Generic.ValueDictionary`2.Enumerator.MoveNext">
            <summary>
            Moves the iterator to the next element.
            </summary>
            <returns>
            A <see cref="T:System.Boolean"/> result indicating whether the moving operation is successful.
            </returns>
            <exception cref="T:System.InvalidOperationException">Throws when the version value is invalid.</exception>
        </member>
        <member name="P:System.Collections.Generic.ValueDictionary`2.Enumerator.Current">
            <summary>
            Indicates the current element that iterated.
            </summary>
        </member>
        <member name="T:System.Collections.Generic.ValueDictionary`2.KeyCollection">
            <summary>
            Indicates the key collection that only iterates key set.
            </summary>
        </member>
        <member name="F:System.Collections.Generic.ValueDictionary`2.KeyCollection._dictionary">
            <summary>
            Indicates the dictionary instance.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.ValueDictionary`2.KeyCollection.#ctor(System.Collections.Generic.ValueDictionary{`0,`1}@)">
            <summary>
            Initializes an instance with the specified dictionary.
            </summary>
            <param name="dictionary">The dictionary.</param>
        </member>
        <member name="P:System.Collections.Generic.ValueDictionary`2.KeyCollection.Count">
            <summary>
            Indicates the number of keys in this collection.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.ValueDictionary`2.KeyCollection.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the current collection into an array of <typeparamref name="TKey"/>s.
            </summary>
            <param name="array">The array.</param>
            <param name="index">The index.</param>
            <exception cref="T:System.IndexOutOfRangeException">
            Throws when the argument <paramref name="index"/> is out of range.
            </exception>
            <exception cref="T:System.ArgumentException">
            Throws when the <paramref name="array"/> is too small.
            </exception>
        </member>
        <member name="M:System.Collections.Generic.ValueDictionary`2.KeyCollection.GetEnumerator">
            <summary>
            Gets the enumerator that can iterates the key collection.
            </summary>
            <returns>The enumerator that can iterates the key collection.</returns>
        </member>
        <member name="T:System.Collections.Generic.ValueDictionary`2.KeyCollection.Enumerator">
            <summary>
            Indicates the inner enumerator of this collection.
            </summary>
        </member>
        <member name="F:System.Collections.Generic.ValueDictionary`2.KeyCollection.Enumerator._version">
            <summary>
            Indicates the version modified.
            </summary>
        </member>
        <member name="F:System.Collections.Generic.ValueDictionary`2.KeyCollection.Enumerator._dictionary">
            <summary>
            Indicates the dictionary instance.
            </summary>
        </member>
        <member name="F:System.Collections.Generic.ValueDictionary`2.KeyCollection.Enumerator._index">
            <summary>
            Indicates the index.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.ValueDictionary`2.KeyCollection.Enumerator.#ctor(System.Collections.Generic.ValueDictionary{`0,`1}@)">
            <summary>
            Initializes an instance with the specified dictionary.
            </summary>
            <param name="dictionary">The dictionary.</param>
        </member>
        <member name="P:System.Collections.Generic.ValueDictionary`2.KeyCollection.Enumerator.Current">
            <summary>
            Indicates the current element that iterated.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.ValueDictionary`2.KeyCollection.Enumerator.MoveNext">
            <summary>
            Moves the iterator to the next element.
            </summary>
            <returns>
            A <see cref="T:System.Boolean"/> result indicating whether the moving operation is successful.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            Throws when the version value is invalid.
            </exception>
        </member>
        <member name="M:System.Collections.Generic.ValueDictionary`2.KeyCollection.Enumerator.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
            <exception cref="T:System.NotSupportedException">Always throws.</exception>
        </member>
        <member name="M:System.Collections.Generic.ValueDictionary`2.KeyCollection.Enumerator.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
            <exception cref="T:System.NotSupportedException">Always throws.</exception>
        </member>
        <member name="M:System.Collections.Generic.ValueDictionary`2.KeyCollection.Enumerator.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
            <exception cref="T:System.NotSupportedException">Always throws.</exception>
        </member>
        <member name="M:System.Collections.Generic.ValueDictionary`2.KeyCollection.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
            <exception cref="T:System.NotSupportedException">Always throws.</exception>
        </member>
        <member name="M:System.Collections.Generic.ValueDictionary`2.KeyCollection.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
            <exception cref="T:System.NotSupportedException">Always throws.</exception>
        </member>
        <member name="M:System.Collections.Generic.ValueDictionary`2.KeyCollection.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
            <exception cref="T:System.NotSupportedException">Always throws.</exception>
        </member>
        <member name="T:System.Collections.Generic.ValueDictionary`2.ValueCollection">
            <summary>
            Indicates the value collection that only iterates value set.
            </summary>
        </member>
        <member name="F:System.Collections.Generic.ValueDictionary`2.ValueCollection._dictionary">
            <summary>
            Indicates the dictionary instance.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.ValueDictionary`2.ValueCollection.#ctor(System.Collections.Generic.ValueDictionary{`0,`1}@)">
            <summary>
            Initializes an instance with the specified dictionary.
            </summary>
            <param name="dictionary">The dictionary.</param>
        </member>
        <member name="P:System.Collections.Generic.ValueDictionary`2.ValueCollection.Count">
            <summary>
            Indicates the number of keys in this collection.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.ValueDictionary`2.ValueCollection.CopyTo(`1[],System.Int32)">
            <summary>
            Copies the current collection into an array of <typeparamref name="TValue"/>s.
            </summary>
            <param name="array">The array.</param>
            <param name="index">The index.</param>
            <exception cref="T:System.IndexOutOfRangeException">
            Throws when the argument <paramref name="index"/> is out of range.
            </exception>
            <exception cref="T:System.ArgumentException">
            Throws when the <paramref name="array"/> is too small.
            </exception>
        </member>
        <member name="M:System.Collections.Generic.ValueDictionary`2.ValueCollection.GetEnumerator">
            <summary>
            Gets the enumerator that can iterates the value collection.
            </summary>
            <returns>The enumerator that can iterates the value collection.</returns>
        </member>
        <member name="T:System.Collections.Generic.ValueDictionary`2.ValueCollection.Enumerator">
            <summary>
            Indicates the inner enumerator of this collection.
            </summary>
        </member>
        <member name="F:System.Collections.Generic.ValueDictionary`2.ValueCollection.Enumerator._version">
            <summary>
            Indicates the version modified.
            </summary>
        </member>
        <member name="F:System.Collections.Generic.ValueDictionary`2.ValueCollection.Enumerator._dictionary">
            <summary>
            Indicates the dictionary instance.
            </summary>
        </member>
        <member name="F:System.Collections.Generic.ValueDictionary`2.ValueCollection.Enumerator._index">
            <summary>
            Indicates the index.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.ValueDictionary`2.ValueCollection.Enumerator.#ctor(System.Collections.Generic.ValueDictionary{`0,`1}@)">
            <summary>
            Initializes an instance with the specified dictionary.
            </summary>
            <param name="dictionary">The dictionary.</param>
        </member>
        <member name="P:System.Collections.Generic.ValueDictionary`2.ValueCollection.Enumerator.Current">
            <summary>
            Indicates the current element that iterated.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.ValueDictionary`2.ValueCollection.Enumerator.MoveNext">
            <summary>
            Moves the iterator to the next element.
            </summary>
            <returns>
            A <see cref="T:System.Boolean"/> result indicating whether the moving operation is successful.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            Throws when the version value is invalid.
            </exception>
        </member>
        <member name="M:System.Collections.Generic.ValueDictionary`2.ValueCollection.Enumerator.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
            <exception cref="T:System.NotSupportedException">Always throws.</exception>
        </member>
        <member name="M:System.Collections.Generic.ValueDictionary`2.ValueCollection.Enumerator.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
            <exception cref="T:System.NotSupportedException">Always throws.</exception>
        </member>
        <member name="M:System.Collections.Generic.ValueDictionary`2.ValueCollection.Enumerator.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
            <exception cref="T:System.NotSupportedException">Always throws.</exception>
        </member>
        <member name="M:System.Collections.Generic.ValueDictionary`2.ValueCollection.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
            <exception cref="T:System.NotSupportedException">Always throws.</exception>
        </member>
        <member name="M:System.Collections.Generic.ValueDictionary`2.ValueCollection.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
            <exception cref="T:System.NotSupportedException">Always throws.</exception>
        </member>
        <member name="M:System.Collections.Generic.ValueDictionary`2.ValueCollection.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
            <exception cref="T:System.NotSupportedException">Always throws.</exception>
        </member>
        <member name="M:System.Collections.Generic.ValueDictionary`2.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
            <exception cref="T:System.NotSupportedException">Always throws.</exception>
        </member>
        <member name="M:System.Collections.Generic.ValueDictionary`2.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
            <exception cref="T:System.NotSupportedException">Always throws.</exception>
        </member>
        <member name="M:System.Collections.Generic.ValueDictionary`2.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
            <exception cref="T:System.NotSupportedException">Always throws.</exception>
        </member>
        <member name="T:System.Collections.Generic.KeyedTuple`2">
            <summary>
            Provides a tuple with a primary element, which means the tuple contains multiple items,
            but the only specified item can be output as <see cref="T:System.String"/> text.
            </summary>
            <typeparam name="T1">The type of the property <see cref="P:System.Collections.Generic.KeyedTuple`2.Item1"/>.</typeparam>
            <typeparam name="T2">The type of the property <see cref="P:System.Collections.Generic.KeyedTuple`2.Item2"/>.</typeparam>
            <param name="Item1">The 1st item.</param>
            <param name="Item2">The 2nd item.</param>
            <param name="PriorKey">The prior key.</param>
        </member>
        <member name="M:System.Collections.Generic.KeyedTuple`2.#ctor(`0,`1,System.Int32)">
            <summary>
            Provides a tuple with a primary element, which means the tuple contains multiple items,
            but the only specified item can be output as <see cref="T:System.String"/> text.
            </summary>
            <typeparam name="T1">The type of the property <see cref="P:System.Collections.Generic.KeyedTuple`2.Item1"/>.</typeparam>
            <typeparam name="T2">The type of the property <see cref="P:System.Collections.Generic.KeyedTuple`2.Item2"/>.</typeparam>
            <param name="Item1">The 1st item.</param>
            <param name="Item2">The 2nd item.</param>
            <param name="PriorKey">The prior key.</param>
        </member>
        <member name="M:System.Collections.Generic.KeyedTuple`2.#ctor(`0,`1)">
            <summary>
            Initializes an instance with the specified 2 items, and the first one is the prior key.
            </summary>
            <param name="item1">The item 1.</param>
            <param name="item2">The item 2.</param>
        </member>
        <member name="P:System.Collections.Generic.KeyedTuple`2.System#Runtime#CompilerServices#ITuple#Length">
            <inheritdoc/>
        </member>
        <member name="P:System.Collections.Generic.KeyedTuple`2.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:System.Collections.Generic.KeyedTuple`2.ToString">
            <inheritdoc/>
        </member>
        <member name="T:System.Collections.Generic.KeyedTuple`3">
            <summary>
            Provides a tuple with a primary element, which means the tuple contains multiple items,
            but the only specified item can be output as <see cref="T:System.String"/> text.
            </summary>
            <typeparam name="T1">The type of the property <see cref="P:System.Collections.Generic.KeyedTuple`3.Item1"/>.</typeparam>
            <typeparam name="T2">The type of the property <see cref="P:System.Collections.Generic.KeyedTuple`3.Item2"/>.</typeparam>
            <typeparam name="T3">The type of the property <see cref="P:System.Collections.Generic.KeyedTuple`3.Item3"/>.</typeparam>
            <param name="Item1">The 1st item.</param>
            <param name="Item2">The 2nd item.</param>
            <param name="Item3">The 3rd item.</param>
            <param name="PriorKey">The prior key.</param>
        </member>
        <member name="M:System.Collections.Generic.KeyedTuple`3.#ctor(`0,`1,`2,System.Int32)">
            <summary>
            Provides a tuple with a primary element, which means the tuple contains multiple items,
            but the only specified item can be output as <see cref="T:System.String"/> text.
            </summary>
            <typeparam name="T1">The type of the property <see cref="P:System.Collections.Generic.KeyedTuple`3.Item1"/>.</typeparam>
            <typeparam name="T2">The type of the property <see cref="P:System.Collections.Generic.KeyedTuple`3.Item2"/>.</typeparam>
            <typeparam name="T3">The type of the property <see cref="P:System.Collections.Generic.KeyedTuple`3.Item3"/>.</typeparam>
            <param name="Item1">The 1st item.</param>
            <param name="Item2">The 2nd item.</param>
            <param name="Item3">The 3rd item.</param>
            <param name="PriorKey">The prior key.</param>
        </member>
        <member name="M:System.Collections.Generic.KeyedTuple`3.#ctor(`0,`1,`2)">
            <summary>
            Initializes an instance with the specified 3 items, and the first one is the prior key.
            </summary>
            <param name="item1">The item 1.</param>
            <param name="item2">The item 2.</param>
            <param name="item3">The item 3.</param>
        </member>
        <member name="P:System.Collections.Generic.KeyedTuple`3.System#Runtime#CompilerServices#ITuple#Length">
            <inheritdoc/>
        </member>
        <member name="P:System.Collections.Generic.KeyedTuple`3.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:System.Collections.Generic.KeyedTuple`3.ToString">
            <inheritdoc/>
        </member>
        <member name="T:System.Collections.Generic.KeyedTuple`4">
            <summary>
            Provides a tuple with a primary element, which means the tuple contains multiple items,
            but the only specified item can be output as <see cref="T:System.String"/> text.
            </summary>
            <typeparam name="T1">The type of the property <see cref="P:System.Collections.Generic.KeyedTuple`4.Item1"/>.</typeparam>
            <typeparam name="T2">The type of the property <see cref="P:System.Collections.Generic.KeyedTuple`4.Item2"/>.</typeparam>
            <typeparam name="T3">The type of the property <see cref="P:System.Collections.Generic.KeyedTuple`4.Item3"/>.</typeparam>
            <typeparam name="T4">The type of the property <see cref="P:System.Collections.Generic.KeyedTuple`4.Item4"/>.</typeparam>
            <param name="Item1">The 1st item.</param>
            <param name="Item2">The 2nd item.</param>
            <param name="Item3">The 3rd item.</param>
            <param name="Item4">The 4th item.</param>
            <param name="PriorKey">The prior key.</param>
        </member>
        <member name="M:System.Collections.Generic.KeyedTuple`4.#ctor(`0,`1,`2,`3,System.Int32)">
            <summary>
            Provides a tuple with a primary element, which means the tuple contains multiple items,
            but the only specified item can be output as <see cref="T:System.String"/> text.
            </summary>
            <typeparam name="T1">The type of the property <see cref="P:System.Collections.Generic.KeyedTuple`4.Item1"/>.</typeparam>
            <typeparam name="T2">The type of the property <see cref="P:System.Collections.Generic.KeyedTuple`4.Item2"/>.</typeparam>
            <typeparam name="T3">The type of the property <see cref="P:System.Collections.Generic.KeyedTuple`4.Item3"/>.</typeparam>
            <typeparam name="T4">The type of the property <see cref="P:System.Collections.Generic.KeyedTuple`4.Item4"/>.</typeparam>
            <param name="Item1">The 1st item.</param>
            <param name="Item2">The 2nd item.</param>
            <param name="Item3">The 3rd item.</param>
            <param name="Item4">The 4th item.</param>
            <param name="PriorKey">The prior key.</param>
        </member>
        <member name="M:System.Collections.Generic.KeyedTuple`4.#ctor(`0,`1,`2,`3)">
            <summary>
            Initializes an instance with the specified 4 items, and the first one is the prior key.
            </summary>
            <param name="item1">The item 1.</param>
            <param name="item2">The item 2.</param>
            <param name="item3">The item 3.</param>
            <param name="item4">The item 4.</param>
        </member>
        <member name="P:System.Collections.Generic.KeyedTuple`4.System#Runtime#CompilerServices#ITuple#Length">
            <inheritdoc/>
        </member>
        <member name="P:System.Collections.Generic.KeyedTuple`4.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:System.Collections.Generic.KeyedTuple`4.ToString">
            <inheritdoc/>
        </member>
        <member name="T:System.Collections.HashHelpers">
            <summary>
            Encapsulates and provides the methods about hash code handling.
            </summary>
        </member>
        <member name="F:System.Collections.HashHelpers.HashCollisionThreshold">
            <summary>
            Indicates the threshold on the hash collision case.
            </summary>
        </member>
        <member name="F:System.Collections.HashHelpers.MaxPrimeArrayLength">
            <summary>
            Indiactes the maximum prime number of the type <see cref="T:System.Int32"/>
            smaller than <see cref="P:System.Array.MaxLength"/>..
            </summary>
            <seealso cref="P:System.Array.MaxLength"/>
            <remarks>
            The next prime is <c>2147483629</c>, which is bigger than <see cref="P:System.Array.MaxLength"/>
            though it is still in the valid range of <see cref="T:System.Int32"/> type.
            </remarks>
        </member>
        <member name="F:System.Collections.HashHelpers.HashPrime">
            <summary>
            Indicates the hash prime number used.
            </summary>
        </member>
        <member name="F:System.Collections.HashHelpers.Primes">
            <summary>
            <para>
            Table of prime numbers to use as hash table sizes.
            A typical resize algorithm would pick the smallest prime number in this array
            that is larger than twice the previous capacity.
            </para>
            <para>
            Suppose our Hashtable currently has capacity <c>x</c> and enough elements are added
            such that a resize needs to occur. Resizing first computes <c>2x</c> then finds the
            first prime in the table greater than <c>2x</c>, i.e. if primes are ordered
            <c>p_1, p_2, ..., p_i, ...</c>, it finds <c>p_n</c> such that <c><![CDATA[p_n-1 < 2x < p_n]]></c>.
            Doubling is important for preserving the asymptotic complexity of the
            hashtable operations such as add.  Having a prime guarantees that double
            hashing does not lead to infinite loops.  IE, your hash function will be
            <c><![CDATA[h1(key) + i * h2(key)]]></c>, <c><![CDATA[0 <= i < size]]></c>.
            <c>h2</c> and the size must be relatively prime.
            </para>
            <para>
            We prefer the low computation costs of higher prime numbers over the increased
            memory allocation of a fixed prime number i.e. when right sizing a <c>HashSet</c>.
            </para>
            </summary>
        </member>
        <member name="M:System.Collections.HashHelpers.IsPrime(System.Int32)">
            <summary>
            Checks whether the specified candidate number is a prime number using the normal algorithm.
            </summary>
            <param name="candidate">The number to check.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:System.Collections.HashHelpers.GetPrime(System.Int32)">
            <summary>
            Gets a prime number.
            </summary>
            <param name="threshold">
            The minimum value as the threshold. The return value will be greater than this value.
            </param>
            <returns>The result prime number.</returns>
            <exception cref="T:System.ArgumentException">
            Throws when the argument <paramref name="threshold"/> is a negative value.
            </exception>
        </member>
        <member name="M:System.Collections.HashHelpers.ExpandPrime(System.Int32)">
            <summary>
            Expand the prime number from an old size.
            </summary>
            <param name="oldSize">The old size.</param>
            <returns>Returns size of hashtable to grow to.</returns>
        </member>
        <member name="M:System.Collections.HashHelpers.GetFastModMultiplier(System.UInt32)">
            <summary>
            Returns approximate reciprocal of the divisor: <c>Ceil(Pow(2, 64) / divisor)</c>.
            </summary>
            <remarks>This should only be used on 64-bit.</remarks>
        </member>
        <member name="M:System.Collections.HashHelpers.FastMod(System.UInt32,System.UInt32,System.UInt64)">
            <summary>
            Performs a mod operation using the multiplier pre-computed with <see cref="M:System.Collections.HashHelpers.GetFastModMultiplier(System.UInt32)"/>.
            </summary>
            <remarks>This should only be used on 64-bit.</remarks>
            <seealso cref="M:System.Collections.HashHelpers.GetFastModMultiplier(System.UInt32)"/>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.AssemblyObsoleteAttribute">
            <summary>
            To mark on an assembly, to tell the user and the compiler that the assembly is obsolete.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.ClosedAttribute">
            <summary>
            Marks on a enumeration type, which means the enumeration type is a closed enumeration type.
            </summary>
            <remarks>
            A closed enumeration type is a type that only holds the value in the enumeration declaration field
            (i.e. the curly bracket). For example, the code
            <code>
            [Closed] public enum Gender { Boy; Girl; }
            </code>
            Which means the type <c>Gender</c> is a closed enumeration type, and you can't use arithmetic operators
            (such as <c>operator +</c>) to get the fields that don't appear
            in the declaration <c>{ Boy; Girl; }</c> (e.g. <c>Gender.Boy + Gender.Girl</c>,
            <c>Gender.Boy + 1</c>, etc.). In other words, you can only use those fields as the references
            instead of any calculations.
            </remarks>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DiscardAttribute">
            <summary>
            Indicates the marked parameter is a discard and can't be used.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullWhenNotDefinedAttribute">
            <summary>
            Indicates the return value may be <see langword="null"/> when the specified enumeration-typed
            argument isn't defined.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MaybeNullWhenNotDefinedAttribute.#ctor(System.String)">
            <summary>
            Initializes the <see cref="T:System.Diagnostics.CodeAnalysis.MaybeNullWhenNotDefinedAttribute"/> instance
            with a specified argument name.
            </summary>
            <param name="argumentName">The argument name.</param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenNotDefinedAttribute.ArgumentName">
            <summary>
            Indicates the argument name that is of an enumeration type.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.RefStructTypeAttribute">
            <summary>
            Marks on a generic type parameter, to tell the compiler that the type is a <see langword="ref struct"/>.
            </summary>
        </member>
        <member name="T:System.Extensions.BitArrayEx">
            <summary>
            Provides extension methods on <see cref="T:System.Collections.BitArray"/>.
            </summary>
            <seealso cref="T:System.Collections.BitArray"/>
        </member>
        <member name="M:System.Extensions.BitArrayEx.GetCardinality(System.Collections.BitArray)">
            <summary>
            Get the cardinality of the specified <see cref="T:System.Collections.BitArray"/>.
            </summary>
            <param name="this">The array.</param>
            <returns>The total number of bits set <see langword="true"/>.</returns>
        </member>
        <member name="T:System.Extensions.CharEx">
            <summary>
            Provides extension methods on <see cref="T:System.Char"/>.
            </summary>
            <seealso cref="T:System.Char"/>
        </member>
        <member name="M:System.Extensions.CharEx.IsAsciiPuncuation(System.Char)">
            <summary>
            Checks whether the specified character is a punctuation that is in the range ASCII.
            </summary>
            <param name="this">The character.</param>
            <returns>The <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="T:System.Extensions.CloneableEx">
            <summary>
            Provides extension methods on <see cref="T:System.ICloneable"/>.
            </summary>
            <seealso cref="T:System.ICloneable"/>
        </member>
        <member name="M:System.Extensions.CloneableEx.TryCloneAs``1(System.ICloneable)">
            <summary>
            Clone this object and try to cast to the specified type.
            If the type is invalid to cast, the return value will be <see langword="null"/>.
            </summary>
            <typeparam name="TClass">
            The type to cast. The type should be a <see langword="class"/> because the type
            to implement <see cref="T:System.ICloneable"/> should be a reference type.
            </typeparam>
            <param name="this">The object.</param>
            <returns>
            The cast result. If cast is valid, the value will be so valid; otherwise,
            <see langword="null"/>.
            </returns>
        </member>
        <member name="M:System.Extensions.CloneableEx.CloneAs``1(System.ICloneable)">
            <summary>
            Clone this object and cast to the specified type no matter how.
            </summary>
            <typeparam name="TClass">
            The type to cast. The type should be a <see langword="class"/> because the type
            to implement <see cref="T:System.ICloneable"/> should be a reference type.
            </typeparam>
            <param name="this">The object.</param>
            <returns>The cast result.</returns>
        </member>
        <member name="M:System.Extensions.CloneableEx.Cast``1(System.ICloneable)">
            <summary>
            Try to cast the current instance to the generic cloneable type <see cref="T:System.ICloneable`1"/>.
            </summary>
            <typeparam name="TClass">The type of the instance.</typeparam>
            <param name="this">The object.</param>
            <returns>The cast result. If cast is invalid, the return value will be <see langword="null"/>.</returns>
            <seealso cref="T:System.ICloneable`1"/>
        </member>
        <member name="T:System.Extensions.CollectionEx">
            <summary>
            Provides extension methods on <see cref="T:System.Collections.Generic.ICollection`1"/> and <see cref="T:System.Collections.Generic.IReadOnlyCollection`1"/>.
            </summary>
            <seealso cref="T:System.Collections.Generic.ICollection`1"/>
            <seealso cref="T:System.Collections.Generic.IReadOnlyCollection`1"/>
        </member>
        <member name="M:System.Extensions.CollectionEx.AddRange``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Adds the elements of the specified collection to the end of the
            <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="this">The collection.</param>
            <param name="values">
            The values you want to add to the end of the collection.
            </param>
        </member>
        <member name="M:System.Extensions.CollectionEx.AddIfDoesNotContain``1(System.Collections.Generic.ICollection{``0},``0)">
            <summary>
            Adds an object to the end of the <see cref="T:System.Collections.Generic.ICollection`1"/> when
            the specified list doesn't contain the specified element.
            </summary>
            <typeparam name="T">The type of all elements.</typeparam>
            <param name="this">The list.</param>
            <param name="item">The item to add.</param>
        </member>
        <member name="T:System.Extensions.DictionaryEx">
            <summary>
            Provides extension methods on <see cref="T:System.Collections.Generic.Dictionary`2"/>.
            </summary>
            <seealso cref="T:System.Collections.Generic.Dictionary`2"/>
        </member>
        <member name="M:System.Extensions.DictionaryEx.ToArray``3(System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            Converts the specified dictionary to an array, if each value can be iterated.
            </summary>
            <typeparam name="TKey">The type of the key of the dictionary.</typeparam>
            <typeparam name="TValue">The type of each value.</typeparam>
            <typeparam name="T">
            The iterator type, which means the iteration type for the <typeparamref name="TValue"/>
            instances.
            </typeparam>
            <param name="this">The dictionary.</param>
            <returns>The result array.</returns>
        </member>
        <member name="M:System.Extensions.DictionaryEx.TryAddRange``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}})">
            <summary>
            Try to add a series of elements into the dictionary.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">The type of the element.</typeparam>
            <param name="this">The dictionary.</param>
            <param name="list">The list to add into the dictionary.</param>
            <returns>The number of elements that is successful to add.</returns>
        </member>
        <member name="T:System.Extensions.DoubleEx">
            <summary>
            Provides extension methods on <see cref="T:System.Double"/>.
            </summary>
            <seealso cref="T:System.Double"/>
        </member>
        <member name="M:System.Extensions.DoubleEx.NearlyEquals(System.Double,System.Double)">
            <summary>
            Indicates whether the specified value is nearly equals to the current value.
            </summary>
            <param name="this">The value.</param>
            <param name="other">The other value.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:System.Extensions.DoubleEx.NearlyEquals(System.Double,System.Double,System.Double)">
            <summary>
            Indicates whether the specified value is nearly equals to the current value.
            If the differ of two values to compare is lower than the specified epsilon value,
            the method will return <see langword="true"/>.
            </summary>
            <param name="this">The value.</param>
            <param name="other">The other value to compare.</param>
            <param name="epsilon">The epsilon value (the minimal differ).</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="T:System.Extensions.EnumerableEx">
            <summary>
            Provides a set of static methods for querying objects that implement
            <see cref="T:System.Collections.IEnumerable"/> and <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <remarks>This class has the same function and status with <see cref="T:System.Linq.Enumerable"/>.</remarks>
            <seealso cref="T:System.Collections.IEnumerable"/>
            <seealso cref="T:System.Collections.Generic.IEnumerable`1"/>
            <seealso cref="T:System.Linq.Enumerable"/>
        </member>
        <member name="M:System.Extensions.EnumerableEx.HasOnlyOneElement``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Check whether the specified list has only one element.
            </summary>
            <typeparam name="T">The type of the element.</typeparam>
            <param name="this">The list.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:System.Extensions.EnumerableEx.Contains``1(System.Collections.Generic.IEnumerable{``0},``0[])">
            <summary>
            Check whether the list contains the element that is in the specified array.
            </summary>
            <typeparam name="TEquatable">The type of the element to check.</typeparam>
            <param name="this">The list.</param>
            <param name="elements">
            The array that contains the target elements.
            </param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:System.Extensions.EnumerableEx.ContainsType``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Check whether the collection contains any elements that match the specified type.
            </summary>
            <typeparam name="T">The type to check.</typeparam>
            <param name="this">The list.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:System.Extensions.EnumerableEx.IndexOf``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>
            Get the index of the whole list, whose corresponding element is satisfy the specified condition.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="this">The list.</param>
            <param name="predicate">The condition to check.</param>
            <returns>
            The index of the element satisfied the condition. If the list can't find that element,
            return -1 as the result.
            </returns>
        </member>
        <member name="T:System.Extensions.EnumEx">
            <summary>
            Provides extension methods on <see cref="T:System.Enum"/>.
            </summary>
            <seealso cref="T:System.Enum"/>
        </member>
        <member name="M:System.Extensions.EnumEx.IsFlag``1(``0)">
            <summary>
            Checks whether the current enumeration field is a flag.
            </summary>
            <typeparam name="TEnum">The type of the current field.</typeparam>
            <param name="this">The current field to check.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:System.Extensions.EnumEx.Min``1(``0,``0)">
            <summary>
            Check which enumeration field is less.
            </summary>
            <typeparam name="TEnum">The type of the enumeration field to compare.</typeparam>
            <param name="left">The left one.</param>
            <param name="right">The right one.</param>
            <returns>The comparison result.</returns>
        </member>
        <member name="M:System.Extensions.EnumEx.Max``1(``0,``0)">
            <summary>
            Check which enumeration field is greater.
            </summary>
            <typeparam name="TEnum">The type of the enumeration field to compare.</typeparam>
            <param name="left">The left one.</param>
            <param name="right">The right one.</param>
            <returns>The comparison result.</returns>
        </member>
        <member name="M:System.Extensions.EnumEx.GetAllFlags``1(``0)">
            <summary>
            To get all possible flags from a specified enumeration instance.
            </summary>
            <typeparam name="TEnum">The type of that enumeration.</typeparam>
            <param name="this">The field.</param>
            <returns>
            All flags. If the enumeration field doesn't contain any flags,
            the return value will be <see langword="null"/>.
            </returns>
        </member>
        <member name="M:System.Extensions.EnumEx.GetEnumerator``1(``0)">
            <summary>
            Get all possible flags that the current enumeration field set.
            </summary>
            <typeparam name="TEnum">The type of the enumeration.</typeparam>
            <param name="this">The current enumeration type instance.</param>
            <returns>All flags.</returns>
        </member>
        <member name="M:System.Extensions.EnumEx.Flags``1(``0,``0)">
            <inheritdoc cref="M:System.Enum.HasFlag(System.Enum)"/>
            <typeparam name="TEnum">The type of the enumeration.</typeparam>
            <param name="this">The current enumeration type instance.</param>
            <param name="other">The other instance to check.</param>
            <remarks>
            This method is same as <see cref="M:System.Enum.HasFlag(System.Enum)"/>, but without boxing and unboxing operations.
            </remarks>
            <exception cref="T:System.ArgumentException">Throws when the used bytes aren't 1, 2 or 4.</exception>
            <seealso cref="M:System.Enum.HasFlag(System.Enum)"/>
        </member>
        <member name="M:System.Extensions.EnumEx.MultiFlags``1(``0,``0)">
            <summary>
            Determines whether the instance has the flags specified as <paramref name="flags"/>.
            </summary>
            <typeparam name="TEnum">The type of the enumeration field.</typeparam>
            <param name="this">The instance.</param>
            <param name="flags">All flags used.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="T:System.Extensions.FormatProviderEx">
            <summary>
            Provides extension methods on <see cref="T:System.IFormatProvider"/>.
            </summary>
            <seealso cref="T:System.IFormatProvider"/>
        </member>
        <member name="M:System.Extensions.FormatProviderEx.HasFormatted``1(System.IFormatProvider,``0@,System.String,System.String@)">
            <summary>
            To check whether the format provider has defined the format rule.
            If the rule is defined, this method will return the string representation
            according to the format rule.
            </summary>
            <param name="this">The format provider.</param>
            <param name="obj">The object.</param>
            <param name="format">The format string.</param>
            <param name="result">
            The result. If the format has been defined,
            this value won't be <see langword="null"/>.
            </param>
            <returns>The <see cref="T:System.Boolean"/> value indicating that.</returns>
            <remarks>
            You should use this as:
            <code>
            if (formatProvider.HasFormatted(this, format, out string? result)) return result;
            </code>
            </remarks>
        </member>
        <member name="T:System.Extensions.ListEx">
            <summary>
            Provides extension methods on <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
            <seealso cref="T:System.Collections.Generic.IList`1"/>
        </member>
        <member name="M:System.Extensions.ListEx.RemoveDuplicateItems``1(System.Collections.Generic.List{``0})">
            <summary>
            Remove duplicate items in the specified list.
            </summary>
            <typeparam name="TEquatable">The type of each elements.</typeparam>
            <param name="this">The list.</param>
            <returns>Returns the reference of the argument <paramref name="this"/>.</returns>
        </member>
        <member name="M:System.Extensions.ListEx.RemoveDuplicateItems``1(System.Collections.Generic.IList{``0})">
            <summary>
            Remove duplicate items in the specified list.
            </summary>
            <typeparam name="TEquatable">The type of each elements.</typeparam>
            <param name="this">The list.</param>
            <returns>Returns the reference of the argument <paramref name="this"/>.</returns>
        </member>
        <member name="M:System.Extensions.ListEx.RemoveLastElement``1(System.Collections.Generic.IList{``0})">
            <summary>
            Remove the last element of the specified list, which is equivalent to code:
            <code>
            list.RemoveAt(list.Count - 1);
            </code>
            or
            <code>
            list.RemoveAt(^1); // Call extension method 'RemoveAt'.
            </code>
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="this">The list.</param>
            <seealso cref="M:System.Extensions.ListEx.RemoveAt``1(System.Collections.Generic.IList{``0},System.Index@)"/>
        </member>
        <member name="M:System.Extensions.ListEx.RemoveAt``1(System.Collections.Generic.IList{``0},System.Index@)">
            <summary>
            Remove at the element in the specified index.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="this">The list.</param>
            <param name="index">The index to remove.</param>
        </member>
        <member name="M:System.Extensions.ListEx.AsReadOnlyList``1(System.Collections.Generic.IList{``0})">
            <summary>
            Try to convert the current list to a <see cref="T:System.Collections.Generic.IReadOnlyList`1"/>.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="this">The list.</param>
            <returns>The result of the conversion.</returns>
            <exception cref="T:System.InvalidCastException">
            Throws when the specified list is neither <see cref="T:System.Collections.Generic.List`1"/> nor <typeparamref name="T"/>[].
            </exception>
        </member>
        <member name="T:System.Extensions.MathEx">
            <summary>
            Provides extension methods on <see cref="T:System.Math"/>.
            </summary>
            <seealso cref="T:System.Math"/>
        </member>
        <member name="M:System.Extensions.MathEx.Min(System.Int32,System.Int32,System.Int32)">
            <summary>
            Get the minimal one of three values.
            </summary>
            <param name="a">The first value.</param>
            <param name="b">The second value.</param>
            <param name="c">The third value.</param>
            <returns>Which is the minimal value.</returns>
        </member>
        <member name="M:System.Extensions.MathEx.Max(System.Int32,System.Int32,System.Int32)">
            <summary>
            Get the maximum one of three values.
            </summary>
            <param name="a">The first value.</param>
            <param name="b">The second value.</param>
            <param name="c">The third value.</param>
            <returns>Which is the maximum value.</returns>
        </member>
        <member name="T:System.Extensions.MemberInfoEx">
            <summary>
            Provides extension methods on <see cref="T:System.Reflection.MemberInfo"/>.
            </summary>
            <seealso cref="T:System.Reflection.MemberInfo"/>
        </member>
        <member name="M:System.Extensions.MemberInfoEx.IsDefined``1(System.Reflection.MemberInfo)">
            <summary>
            Indicates whether custom attributes of a specified type are applied to a specified member.
            </summary>
            <typeparam name="TAttribute">The type of that attribute.</typeparam>
            <param name="this">The member information instance.</param>
            <returns>
            <see langword="true"/> if an attribute of the specified type is applied to <paramref name="this"/>;
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="T:System.Extensions.Pointer">
            <summary>
            Provides methods on pointers.
            </summary>
            <remarks>
            Different with other types, pointers can't be as <see langword="this"/> parameter.
            </remarks>
        </member>
        <member name="M:System.Extensions.Pointer.Swap``1(``0*,``0*)">
            <summary>
            To swap the two variables using pointers when the pointee is an <see langword="unmanaged"/> type.
            </summary>
            <typeparam name="TUnmanaged">The type of the variable.</typeparam>
            <param name="left">The left variable.</param>
            <param name="right">The right variable.</param>
        </member>
        <member name="M:System.Extensions.Pointer.StringLengthOf(System.Char*)">
            <summary>
            Get the length of the specified string which is represented by a <see cref="T:System.Char"/>*.
            </summary>
            <param name="ptr">The pointer.</param>
            <returns>The total length.</returns>
            <remarks>
            In C#, this function is unsafe because the implementation of
            <see cref="T:System.String"/> types between C and C# is totally different.
            In C, <see cref="T:System.String"/> is like a <see cref="T:System.Char"/>* or a
            <see cref="T:System.Char"/>[], they ends with the terminator symbol <c>'\0'</c>.
            However, C# not.
            </remarks>
        </member>
        <member name="M:System.Extensions.Pointer.GetArrayFromStart``1(``0*,System.Int32,System.Int32)">
            <summary>
            Get the new array from the pointer, with the specified start index.
            </summary>
            <typeparam name="TUnmanaged">
            The type of the pointer element. Note that the type should be <see langword="unmanaged"/>
            in order to use pointer handling. Therefore, <see langword="managed"/> types shouldn't be allowed.
            </typeparam>
            <param name="ptr">The pointer.</param>
            <param name="length">The length of the array that pointer points to.</param>
            <param name="index">The start index that you want to pick from.</param>
            <returns>The array of elements.</returns>
            <remarks>
            For example, the pointer is the address of the first element in an array <c>{ 0, 1, 3, 6, 10 }</c>,
            if parameter <paramref name="index"/> is 2, the return array will be <c>{ 3, 6, 10 }</c>. Note that
            the parameter <paramref name="length"/> should keep the value 5 because the array contains
            5 elements in this case.
            </remarks>
        </member>
        <member name="M:System.Extensions.Pointer.GetArrayFromStart(System.Int32*,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Get the new array from the pointer, with the specified start index.
            </summary>
            <param name="ptr">The pointer.</param>
            <param name="length">The length of the array that pointer points to.</param>
            <param name="index">The start index that you want to pick from.</param>
            <param name="removeTrailingZeros">
            Indicates whether the method will remove the trailing zeros. If <see langword="false"/>,
            the method will be same as <see cref="M:System.Extensions.Pointer.GetArrayFromStart``1(``0*,System.Int32,System.Int32)"/>.
            </param>
            <returns>The array of elements.</returns>
            <remarks>
            For example, the pointer is the address of the first element in an array <c>{ 0, 1, 3, 6, 10 }</c>,
            if parameter <paramref name="index"/> is 2, the return array will be <c>{ 3, 6, 10 }</c>. Note that
            the parameter <paramref name="length"/> should keep the value 5 because the array contains
            5 elements in this case.
            </remarks>
            <seealso cref="M:System.Extensions.Pointer.GetArrayFromStart``1(``0*,System.Int32,System.Int32)"/>
        </member>
        <member name="T:System.Extensions.ReadOnlyListEx">
            <summary>
            Provides extension methods on <see cref="T:System.Collections.Generic.IReadOnlyList`1"/>.
            </summary>
            <seealso cref="T:System.Collections.Generic.IReadOnlyList`1"/>
        </member>
        <member name="M:System.Extensions.ReadOnlyListEx.Slice``1(System.Collections.Generic.IReadOnlyList{``0},System.Int32,System.Int32)">
            <summary>
            Returns the list that is in the range specified as two parameters called
            <paramref name="start"/> and <paramref name="length"/>.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="this">The list.</param>
            <param name="start">The start index.</param>
            <param name="length">The end index.</param>
            <returns>The list of the elements that is in the specified range.</returns>
        </member>
        <member name="M:System.Extensions.ReadOnlyListEx.FindIndexOf``1(System.Collections.Generic.IReadOnlyList{``0},System.Predicate{``0})">
            <summary>
            Find the index of an element that satisfy the specified condition.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="this">The list.</param>
            <param name="predicate">The condition.</param>
            <returns>
            The result index of that element. If the list doesn't contain any element to satisfy the condition,
            the method will return -1 as the result.
            </returns>
        </member>
        <member name="T:System.Extensions.ReadOnlySpanEx">
            <summary>
            Provides extension methods on <see cref="T:System.ReadOnlySpan`1"/>.
            </summary>
            <seealso cref="T:System.ReadOnlySpan`1"/>
        </member>
        <member name="M:System.Extensions.ReadOnlySpanEx.Select``2(System.ReadOnlySpan{``0}@,System.Func{``0,``1})">
            <summary>
            The select method used in <see langword="from"/>-<see langword="in"/>-<see langword="select"/>
            clause.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <typeparam name="TResult">The result type.</typeparam>
            <param name="this">The list.</param>
            <param name="selector">The selector that is used for conversion.</param>
            <returns>The array of target result elements.</returns>
            <example>
            For example:
            <code>
            <see langword="int"/>[] selection = <see langword="from"/> digit <see langword="in"/> 17.GetAllSets() <see langword="select"/> digit + 1;
            </code>
            </example>
        </member>
        <member name="M:System.Extensions.ReadOnlySpanEx.GetSubsets``1(System.ReadOnlySpan{``0}@,System.Int32)">
            <summary>
            Get all subsets from the specified number of the values to take.
            </summary>
            <param name="this">The array.</param>
            <param name="count">The number of elements you want to take.</param>
            <returns>All subsets.</returns>
        </member>
        <member name="T:System.Extensions.SingleEx">
            <summary>
            Provides extension methods on <see cref="T:System.Single"/>.
            </summary>
            <seealso cref="T:System.Single"/>
        </member>
        <member name="M:System.Extensions.SingleEx.NearlyEquals(System.Single,System.Single)">
            <summary>
            Indicates whether the specified value is nearly equals to the current value.
            </summary>
            <param name="this">The value.</param>
            <param name="other">The other value.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:System.Extensions.SingleEx.NearlyEquals(System.Single,System.Single,System.Single)">
            <summary>
            Indicates whether the specified value is nearly equals to the current value.
            If the differ of two values to compare is lower than the specified epsilon value,
            the method will return <see langword="true"/>.
            </summary>
            <param name="this">The value.</param>
            <param name="other">The other value to compare.</param>
            <param name="epsilon">The epsilon value (the minimal differ).</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="T:System.Extensions.SpanEx">
            <summary>
            Provides extension methods on <see cref="T:System.Span`1"/>.
            </summary>
            <seealso cref="T:System.Span`1"/>
        </member>
        <member name="M:System.Extensions.SpanEx.Select``2(System.Span{``0}@,System.Func{``0,``1})">
            <summary>
            The select method used in <see langword="from"/>-<see langword="in"/>-<see langword="select"/>
            clause.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <typeparam name="TResult">The result type.</typeparam>
            <param name="this">The list.</param>
            <param name="selector">The selector that is used for conversion.</param>
            <returns>The array of target result elements.</returns>
            <example>
            For example:
            <code>
            <see langword="int"/>[] selection = <see langword="from"/> digit <see langword="in"/> 17.GetAllSets() <see langword="select"/> digit + 1;
            </code>
            </example>
        </member>
        <member name="M:System.Extensions.SpanEx.GetSubsets``1(System.Span{``0}@,System.Int32)">
            <summary>
            Get all subsets from the specified number of the values to take.
            </summary>
            <param name="this">The array.</param>
            <param name="count">The number of elements you want to take.</param>
            <returns>All subsets.</returns>
        </member>
        <member name="T:System.Extensions.StringBuilderEx">
            <summary>
            Provides extension methods on <see cref="T:System.Text.StringBuilder"/>.
            </summary>
            <seealso cref="T:System.Text.StringBuilder"/>
        </member>
        <member name="M:System.Extensions.StringBuilderEx.Reverse(System.Text.StringBuilder)">
            <summary>
            Reverse all characters in a specified string builder instance.
            </summary>
            <param name="this">
            The instance to reverse all characters.
            </param>
            <returns>The reference of the current instance.</returns>
        </member>
        <member name="M:System.Extensions.StringBuilderEx.RemoveFrom(System.Text.StringBuilder,System.Int32)">
            <summary>
            Remove all characters hehind the character whose index is specified.
            </summary>
            <param name="this">The instance to remove characters.</param>
            <param name="startIndex">The start index.</param>
            <returns>The reference of the current instance.</returns>
        </member>
        <member name="M:System.Extensions.StringBuilderEx.RemoveFrom(System.Text.StringBuilder,System.Index@)">
            <summary>
            Remove all characters behind the character whose index is specified.
            </summary>
            <param name="this">The instance to remove characters.</param>
            <param name="startIndex">The start index.</param>
            <returns>The reference of the current instance.</returns>
        </member>
        <member name="M:System.Extensions.StringBuilderEx.RemoveFromEnd(System.Text.StringBuilder,System.Int32)">
            <summary>
            Remove the specified number of characters from the end of the string builder
            instance.
            </summary>
            <param name="this">The instance to remove characters.</param>
            <param name="length">The number of characters you want to remove.</param>
            <returns>The reference of the current instance.</returns>
        </member>
        <member name="M:System.Extensions.StringBuilderEx.AppendLine(System.Text.StringBuilder,System.Char)">
            <summary>
            Append a character to the end of the specified string builder instance,
            and then append a <see cref="P:System.Environment.NewLine"/>.
            </summary>
            <param name="this">The instance.</param>
            <param name="value">The character you want to append.</param>
            <returns>The reference of the current instance.</returns>
            <remarks>
            The extension method is used in order to avoid implicit conversion from
            <see cref="T:System.Char"/> to <see cref="T:System.Int32"/>. If you want to append everything,
            please use the method <see cref="M:System.Extensions.StringBuilderEx.AppendLine``1(System.Text.StringBuilder,``0)"/>.
            </remarks>
            <seealso cref="P:System.Environment.NewLine"/>
            <seealso cref="M:System.Extensions.StringBuilderEx.AppendLine``1(System.Text.StringBuilder,``0)"/>
        </member>
        <member name="M:System.Extensions.StringBuilderEx.AppendLine``1(System.Text.StringBuilder,``0)">
            <summary>
            Append a <see cref="T:System.String"/> representation of an object
            to the end of the specified string builder instance,
            and then append a <see cref="P:System.Environment.NewLine"/>.
            </summary>
            <typeparam name="T">The type of the instance to add.</typeparam>
            <param name="this">The instance.</param>
            <param name="obj">
            The <see cref="T:System.String"/> representation of an object you want to append.
            </param>
            <returns>The reference of the current instance.</returns>
            <remarks>
            This method can solve the problem of boxing and unboxing.
            </remarks>
        </member>
        <member name="M:System.Extensions.StringBuilderEx.AppendLines(System.Text.StringBuilder,System.Int32)">
            <summary>
            Append several lines into the <see cref="T:System.Text.StringBuilder"/> instance.
            </summary>
            <param name="this">The instance.</param>
            <param name="lines">The lines you want to add.</param>
            <returns>The reference of the parameter <paramref name="this"/>.</returns>
        </member>
        <member name="M:System.Extensions.StringBuilderEx.NullableAppend(System.Text.StringBuilder,System.String)">
            <summary>
            Append the text into the tail of the <see cref="T:System.Text.StringBuilder"/> object if
            the text is not <see langword="null"/>; otherwise, do nothing.
            </summary>
            <param name="this">The string builder.</param>
            <param name="text">The text to add.</param>
            <returns>The reference of the current instance.</returns>
        </member>
        <member name="M:System.Extensions.StringBuilderEx.NullableAppendLine(System.Text.StringBuilder,System.String)">
            <summary>
            Append the text into the tail of the <see cref="T:System.Text.StringBuilder"/> object if
            the text is not <see langword="null"/>, and then add a terminator at the tail;
            otherwise, do nothing.
            </summary>
            <param name="this">The string builder.</param>
            <param name="text">The text to add.</param>
            <returns>The reference of the current instance.</returns>
        </member>
        <member name="M:System.Extensions.StringBuilderEx.AppendRange``1(System.Text.StringBuilder,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Append a series of elements, and convert them to a <see cref="T:System.String"/> representation.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="this">The list.</param>
            <param name="contentList">All contents.</param>
            <returns>The reference of the current instance.</returns>
        </member>
        <member name="M:System.Extensions.StringBuilderEx.AppendRange``1(System.Text.StringBuilder,System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.String})">
            <summary>
            Append a series of elements, and convert them to a <see cref="T:System.String"/> representation.
            This method allows you defining a custom converter to convert the specified value into
            a string to be appended.
            </summary>
            <typeparam name="TElement">The type of each element.</typeparam>
            <param name="this">The list.</param>
            <param name="contentList">All contents.</param>
            <param name="converter">The converter method specified as a function pointer.</param>
            <returns>The reference of the current instance.</returns>
        </member>
        <member name="M:System.Extensions.StringBuilderEx.AppendRange``1(System.Text.StringBuilder,System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Text.StringBuilder})">
            <summary>
            Append a series of elements, and convert them to a <see cref="T:System.Text.StringBuilder"/> representation.
            This method allows you defining a custom converter to convert the specified value into
            a string to be appended.
            </summary>
            <typeparam name="TElement">The type of each element.</typeparam>
            <param name="this">The list.</param>
            <param name="contentList">All contents.</param>
            <param name="converter">The converter method specified as a function pointer.</param>
            <returns>The reference of the current instance.</returns>
        </member>
        <member name="M:System.Extensions.StringBuilderEx.AppendLineRange``1(System.Text.StringBuilder,System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.String})">
            <summary>
            Append a series of elements, and convert them to a <see cref="T:System.String"/> representation,
            and then append a new line as a separator. This method allows you defining a custom converter
            to convert the specified value into a string to be appended.
            </summary>
            <typeparam name="TElement">The type of each element.</typeparam>
            <param name="this">The list.</param>
            <param name="contentList">All contents.</param>
            <param name="converter">The converter method specified as a function pointer.</param>
            <returns>The reference of the current instance.</returns>
        </member>
        <member name="M:System.Extensions.StringBuilderEx.AppendLineRange``1(System.Text.StringBuilder,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Append a series of elements, and convert them to a <see cref="T:System.String"/> representation, and then
            append a new line as a separator.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="this">The list.</param>
            <param name="contentList">All contents.</param>
            <returns>The reference of the current instance.</returns>
        </member>
        <member name="M:System.Extensions.StringBuilderEx.CopyTo(System.Text.StringBuilder,System.Text.StringBuilder)">
            <summary>
            Copy the specified string builder to the specified target.
            </summary>
            <param name="this">The base string builder.</param>
            <param name="to">The target builder.</param>
            <exception cref="T:System.ArgumentException">
            Throws if the target instance doesn't have enough space to store all characters
            from the base one.
            </exception>
        </member>
        <member name="T:System.Extensions.StringEx">
            <summary>
            Provides extension methods on <see cref="T:System.String"/>.
            </summary>
            <seealso cref="T:System.String"/>
        </member>
        <member name="F:System.Extensions.StringEx.NullLinesOrHeaderSpaces">
            <summary>
            Indicates the regular expression to match all null lines and header spaces in their lines.
            </summary>
        </member>
        <member name="F:System.Extensions.StringEx.MatchingTimeSpan">
            <summary>
            Indicates the time span that is used for matching.
            </summary>
        </member>
        <member name="M:System.Extensions.StringEx.CountOf(System.String,System.Char)">
            <summary>
            Count how many specified characters are in the current string.
            </summary>
            <param name="this">The current string.</param>
            <param name="character">The character to count.</param>
            <returns>The number of characters found.</returns>
        </member>
        <member name="M:System.Extensions.StringEx.SatisfyPattern(System.String,System.String)">
            <summary>
            Check whether the specified string instance is satisfied
            the specified regular expression pattern or not.
            </summary>
            <param name="this">The value to check.</param>
            <param name="pattern">
            The regular expression pattern. If the value is <see langword="null"/>,
            the return value is always <see langword="false"/>.
            </param>
            <returns>A <see cref="T:System.Boolean"/> value indicating that.</returns>
            <exception cref="T:System.Text.RegularExpressions.InvalidRegexStringException">
            Throws when the specified <paramref name="pattern"/> is not an valid regular
            expression pattern.
            </exception>
        </member>
        <member name="M:System.Extensions.StringEx.IsMatch(System.String,System.String)">
            <summary>
            Check whether the specified string instance can match the value
            using the specified regular expression pattern or not.
            </summary>
            <param name="this">The value to match.</param>
            <param name="pattern">The regular expression pattern.</param>
            <returns>A <see cref="T:System.Boolean"/> indicating that.</returns>
            <remarks>
            This method is a syntactic sugar of the calling
            method <see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)"/>.
            </remarks>
            <seealso cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)"/>
            <exception cref="T:System.Text.RegularExpressions.InvalidRegexStringException">
            Throws when the specified <paramref name="pattern"/> is not an valid regular
            expression pattern.
            </exception>
        </member>
        <member name="M:System.Extensions.StringEx.ReplaceAt(System.String,System.Int32,System.Char)">
            <summary>
            Replace the character at the specified index with the new value.
            </summary>
            <param name="this">The current string.</param>
            <param name="index">The index.</param>
            <param name="charToInsert">The string to insert.</param>
            <returns>The result string.</returns>
        </member>
        <member name="M:System.Extensions.StringEx.SliceViaCharacter(System.String,System.Char)">
            <summary>
            Slices the current <see cref="T:System.String"/> instance, via the specified character.
            If the string contains that character, we'll slice the string to get the segment.
            </summary>
            <remarks>
            Please note that even if the character exists in the string, we won't get the segment
            containing that character.
            </remarks>
            <param name="this">The string.</param>
            <param name="ch">The character to check.</param>
            <returns>
            The slice result. If the character doesn't exist in the string,
            <see langword="null"/> will be returned.
            </returns>
        </member>
        <member name="M:System.Extensions.StringEx.Match(System.String,System.String)">
            <summary>
            Searches the specified input string for the first occurrence of
            the specified regular expression pattern.
            </summary>
            <param name="this">The value to match.</param>
            <param name="pattern">The regular expression pattern.</param>
            <returns>
            The value after matching. If failed to match,
            the value will be <see langword="null"/>.
            </returns>
            <remarks>
            This method is a syntactic sugar of the calling
            method <see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)"/>.
            </remarks>
            <seealso cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)"/>
            <exception cref="T:System.Text.RegularExpressions.InvalidRegexStringException">
            Throws when the specified <paramref name="pattern"/> is not an valid regular
            expression pattern.
            </exception>
        </member>
        <member name="M:System.Extensions.StringEx.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
            <summary>
            Searches the input string for the first occurrence of the specified regular
            expression, using the specified matching options.
            </summary>
            <param name="this">The value to match.</param>
            <param name="pattern">The regular expression pattern.</param>
            <param name="regexOption">The matching options.</param>
            <returns>
            The matched string value. If failed to match,
            the value will be <see langword="null"/>.
            </returns>
            <remarks>
            This method is a syntactic sugar of the calling
            method <see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)"/>.
            </remarks>
            <exception cref="T:System.Text.RegularExpressions.InvalidRegexStringException">
            Throws when the specified <paramref name="pattern"/> is not an valid regular
            expression pattern.
            </exception>
            <seealso cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)"/>
        </member>
        <member name="M:System.Extensions.StringEx.MatchAll(System.String,System.String)">
            <summary>
            Searches the specified input string for all occurrences of a
            specified regular expression pattern.
            </summary>
            <param name="this">The value to match.</param>
            <param name="pattern">The regular expression pattern.</param>
            <returns>
            The result after matching. If failed to match,
            the returning array will be an empty string array (has no elements).
            </returns>
            <remarks>
            This method is a syntactic sugar of the calling
            method <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)"/>.
            </remarks>
            <exception cref="T:System.Text.RegularExpressions.InvalidRegexStringException">
            Throws when the specified <paramref name="pattern"/> is not an valid regular
            expression pattern.
            </exception>
            <seealso cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)"/>
        </member>
        <member name="M:System.Extensions.StringEx.MatchAll(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
            <summary>
            Searches the specified input string for all occurrences of a
            specified regular expression pattern, using the specified matching
            options.
            </summary>
            <param name="this">The value to match.</param>
            <param name="pattern">The regular expression pattern.</param>
            <param name="regexOption">The matching options.</param>
            <returns>
            The result after matching. If failed to match,
            the returning array will be an empty string array (has no elements).
            </returns>
            <remarks>
            This method is a syntactic sugar of the calling
            method <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)"/>.
            </remarks>
            <exception cref="T:System.Text.RegularExpressions.InvalidRegexStringException">
            Throws when the specified <paramref name="pattern"/> is not an valid regular
            expression pattern.
            </exception>
            <seealso cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)"/>
        </member>
        <member name="M:System.Extensions.StringEx.Reserve(System.String,System.String)">
            <summary>
            Reserve all characters that satisfy the specified pattern.
            </summary>
            <param name="this">The string.</param>
            <param name="reservePattern">
            The pattern that reserved characters satisfied. All supported patterns are:
            <list type="table">
            <item>
            <term><c>@"\d"</c></term>
            <description>To match a digit.</description>
            </item>
            <item>
            <term><c>@"\t"</c></term>
            <description>To match a tab.</description>
            </item>
            <item>
            <term><c>@"\w"</c></term>
            <description>To match a letter, digit or underscore character <c>'_'</c>.</description>
            </item>
            </list>
            </param>
            <returns>The result string.</returns>
            <remarks>
            For example, if code is <c>"Hello, world!".Reserve(@"\w")</c>, the return value
            won't contain any punctuation marks (i.e. <c>"Helloworld"</c>).
            </remarks>
            <exception cref="T:System.Text.RegularExpressions.InvalidRegexStringException">
            Throws when the <paramref name="reservePattern"/> is invalid (Please expand the description
            of the parameter <paramref name="reservePattern"/> to learn about all valid patterns).
            </exception>
        </member>
        <member name="M:System.Extensions.StringEx.IsRegexPattern(System.String)">
            <summary>
            To check if the current string value is a valid regular
            expression pattern or not.
            </summary>
            <param name="this">The value to check.</param>
            <returns>A <see cref="T:System.Boolean"/> indicating that.</returns>
        </member>
        <member name="M:System.Extensions.StringEx.TrimVerbatim(System.String)">
            <summary>
            Trim all spaces when they started a new line, or null lines.
            </summary>
            <param name="this">The string.</param>
            <returns>The trimmed result.</returns>
            <remarks>
            Note that all null lines and header spaces are removed.
            </remarks>
        </member>
        <member name="M:System.Extensions.StringEx.TrimEndNewLine(System.String)">
            <summary>
            Trim new-line characters from the tail of the string.
            </summary>
            <param name="this">The string.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:System.Extensions.StringEx.SplitByNewLine(System.String)">
            <summary>
            Split the string with the fixed characters (new line).
            </summary>
            <param name="this">The string.</param>
            <returns>The result.</returns>
        </member>
        <member name="T:System.Extensions.TypeEx">
            <summary>
            Provides extension method on <see cref="T:System.Type"/>.
            </summary>
            <seealso cref="T:System.Type"/>
        </member>
        <member name="M:System.Extensions.TypeEx.IsSubclassOf``1(System.Type)">
            <summary>
            Determine whether the type is the subclass of the specified one.
            </summary>
            <typeparam name="TClass">The specified type to check.</typeparam>
            <param name="this">The type to check.</param>
            <returns>The <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="T:System.Extensions.Utf8JsonReaderEx">
            <summary>
            Provides extension methods on <see cref="T:System.Text.Json.Utf8JsonReader"/>.
            </summary>
            <seealso cref="T:System.Text.Json.Utf8JsonReader"/>
        </member>
        <member name="M:System.Extensions.Utf8JsonReaderEx.ReadObject``1(System.Text.Json.Utf8JsonReader@,System.Text.Json.Serialization.JsonConverter{``0},System.Type,System.Text.Json.JsonSerializerOptions)">
            <summary>
            Try to read an object.
            </summary>
            <typeparam name="T">The object to read.</typeparam>
            <param name="this">The reader instance.</param>
            <param name="converter">The converter to convert the value.</param>
            <param name="type">The type to convert.</param>
            <param name="options">The options on deserialization.</param>
            <returns>The instance.</returns>
        </member>
        <member name="T:System.Extensions.Utf8JsonWriterEx">
            <summary>
            Provides extension methods on <see cref="T:System.Text.Json.Utf8JsonWriter"/>.
            </summary>
            <seealso cref="T:System.Text.Json.Utf8JsonWriter"/>
        </member>
        <member name="M:System.Extensions.Utf8JsonWriterEx.WriteObject``1(System.Text.Json.Utf8JsonWriter,``0,System.Text.Json.Serialization.JsonConverter{``0},System.Text.Json.JsonSerializerOptions)">
            <summary>
            Try to write an object.
            </summary>
            <typeparam name="T">The type of the value.</typeparam>
            <param name="this">The instance.</param>
            <param name="value">The value to serialize.</param>
            <param name="converter">The converter.</param>
            <param name="options">The options on serialization.</param>
        </member>
        <member name="M:System.Extensions.Utf8JsonWriterEx.WriteObjects``1(System.Text.Json.Utf8JsonWriter,System.Collections.Generic.IEnumerable{``0},System.Text.Json.Serialization.JsonConverter{``0},System.Text.Json.JsonSerializerOptions)">
            <summary>
            Try to write a series of objects.
            </summary>
            <typeparam name="T">The type of the value.</typeparam>
            <param name="this">The instance.</param>
            <param name="values">Values to serialize.</param>
            <param name="converter">The converter.</param>
            <param name="options">The options on serialization.</param>
        </member>
        <member name="T:System.Extensions.BitOperationsEx">
            <summary>
            Provides extension methods on <see cref="T:System.Numerics.BitOperations"/>.
            </summary>
            <seealso cref="T:System.Numerics.BitOperations"/>
        </member>
        <member name="M:System.Extensions.BitOperationsEx.GetAllSets(System.SByte)">
            <summary>
            Find all offsets of set bits of the binary representation of a specified value.
            </summary>
            <param name="this">The value.</param>
            <returns>All offsets.</returns>
        </member>
        <member name="M:System.Extensions.BitOperationsEx.GetAllSets(System.Byte)">
            <summary>
            Find all offsets of set bits of the binary representation of a specified value.
            </summary>
            <param name="this">The value.</param>
            <returns>All offsets.</returns>
        </member>
        <member name="M:System.Extensions.BitOperationsEx.GetAllSets(System.Int16)">
            <summary>
            Find all offsets of set bits of the binary representation of a specified value.
            </summary>
            <param name="this">The value.</param>
            <returns>All offsets.</returns>
        </member>
        <member name="M:System.Extensions.BitOperationsEx.GetAllSets(System.UInt16)">
            <summary>
            Find all offsets of set bits of the binary representation of a specified value.
            </summary>
            <param name="this">The value.</param>
            <returns>All offsets.</returns>
        </member>
        <member name="M:System.Extensions.BitOperationsEx.GetAllSets(System.Int32)">
            <summary>
            Find all offsets of set bits of the binary representation of a specified value.
            </summary>
            <param name="this">The value.</param>
            <returns>All offsets.</returns>
        </member>
        <member name="M:System.Extensions.BitOperationsEx.GetAllSets(System.UInt32)">
            <summary>
            Find all offsets of set bits of the binary representation of a specified value.
            </summary>
            <param name="this">The value.</param>
            <returns>All offsets.</returns>
        </member>
        <member name="M:System.Extensions.BitOperationsEx.GetAllSets(System.Int64)">
            <summary>
            Find all offsets of set bits of the binary representation of a specified value.
            </summary>
            <param name="this">The value.</param>
            <returns>All offsets.</returns>
        </member>
        <member name="M:System.Extensions.BitOperationsEx.GetAllSets(System.UInt64)">
            <summary>
            Find all offsets of set bits of the binary representation of a specified value.
            </summary>
            <param name="this">The value.</param>
            <returns>All offsets.</returns>
        </member>
        <member name="M:System.Extensions.BitOperationsEx.GetEnumerator(System.SByte)">
            <summary>
            <para>Extension get enumerator of the type <see cref="T:System.SByte"/>.</para>
            <para>
            This method will allow you to use <see langword="foreach"/> loop to iterate on
            all indices of set bits.
            </para>
            </summary>
            <param name="this">The value.</param>
            <returns>All indices of set bits.</returns>
            <remarks>
            This implementation will allow you use <see langword="foreach"/> loop:
            <code>
            foreach (int setIndex in 17)
            {
            	// Do something...
            }
            </code>
            </remarks>
        </member>
        <member name="M:System.Extensions.BitOperationsEx.GetEnumerator(System.Byte)">
            <summary>
            <para>Extension get enumerator of the type <see cref="T:System.Byte"/>.</para>
            <para>
            This method will allow you to use <see langword="foreach"/> loop to iterate on
            all indices of set bits.
            </para>
            </summary>
            <param name="this">The value.</param>
            <returns>All indices of set bits.</returns>
            <remarks>
            This implementation will allow you use <see langword="foreach"/> loop:
            <code>
            foreach (int setIndex in 17)
            {
            	// Do something...
            }
            </code>
            </remarks>
        </member>
        <member name="M:System.Extensions.BitOperationsEx.GetEnumerator(System.Int16)">
            <summary>
            <para>Extension get enumerator of the type <see cref="T:System.Int16"/>.</para>
            <para>
            This method will allow you to use <see langword="foreach"/> loop to iterate on
            all indices of set bits.
            </para>
            </summary>
            <param name="this">The value.</param>
            <returns>All indices of set bits.</returns>
            <remarks>
            This implementation will allow you use <see langword="foreach"/> loop:
            <code>
            foreach (int setIndex in 17)
            {
            	// Do something...
            }
            </code>
            </remarks>
        </member>
        <member name="M:System.Extensions.BitOperationsEx.GetEnumerator(System.UInt16)">
            <summary>
            <para>Extension get enumerator of the type <see cref="T:System.UInt16"/>.</para>
            <para>
            This method will allow you to use <see langword="foreach"/> loop to iterate on
            all indices of set bits.
            </para>
            </summary>
            <param name="this">The value.</param>
            <returns>All indices of set bits.</returns>
            <remarks>
            This implementation will allow you use <see langword="foreach"/> loop:
            <code>
            foreach (int setIndex in 17)
            {
            	// Do something...
            }
            </code>
            </remarks>
        </member>
        <member name="M:System.Extensions.BitOperationsEx.GetEnumerator(System.Int32)">
            <summary>
            <para>Extension get enumerator of the type <see cref="T:System.Int32"/>.</para>
            <para>
            This method will allow you to use <see langword="foreach"/> loop to iterate on
            all indices of set bits.
            </para>
            </summary>
            <param name="this">The value.</param>
            <returns>All indices of set bits.</returns>
            <remarks>
            This implementation will allow you use <see langword="foreach"/> loop:
            <code>
            foreach (int setIndex in 17)
            {
            	// Do something...
            }
            </code>
            </remarks>
        </member>
        <member name="M:System.Extensions.BitOperationsEx.GetEnumerator(System.UInt32)">
            <summary>
            <para>Extension get enumerator of the type <see cref="T:System.UInt32"/>.</para>
            <para>
            This method will allow you to use <see langword="foreach"/> loop to iterate on
            all indices of set bits.
            </para>
            </summary>
            <param name="this">The value.</param>
            <returns>All indices of set bits.</returns>
            <remarks>
            This implementation will allow you use <see langword="foreach"/> loop:
            <code>
            foreach (int setIndex in 17)
            {
            	// Do something...
            }
            </code>
            </remarks>
        </member>
        <member name="M:System.Extensions.BitOperationsEx.GetEnumerator(System.Int64)">
            <summary>
            <para>Extension get enumerator of the type <see cref="T:System.Int64"/>.</para>
            <para>
            This method will allow you to use <see langword="foreach"/> loop to iterate on
            all indices of set bits.
            </para>
            </summary>
            <param name="this">The value.</param>
            <returns>All indices of set bits.</returns>
            <remarks>
            This implementation will allow you use <see langword="foreach"/> loop:
            <code>
            foreach (int setIndex in 17)
            {
            	// Do something...
            }
            </code>
            </remarks>
        </member>
        <member name="M:System.Extensions.BitOperationsEx.GetEnumerator(System.UInt64)">
            <summary>
            <para>Extension get enumerator of the type <see cref="T:System.UInt64"/>.</para>
            <para>
            This method will allow you to use <see langword="foreach"/> loop to iterate on
            all indices of set bits.
            </para>
            </summary>
            <param name="this">The value.</param>
            <returns>All indices of set bits.</returns>
            <remarks>
            This implementation will allow you use <see langword="foreach"/> loop:
            <code>
            foreach (int setIndex in 17)
            {
            	// Do something...
            }
            </code>
            </remarks>
        </member>
        <member name="M:System.Extensions.BitOperationsEx.GetNextSet(System.Byte,System.Int32)">
            <summary>
            Find a index of the binary representation of a value after the specified index,
            whose bit is set <see langword="true"/>.
            </summary>
            <param name="this">The value.</param>
            <param name="index">The index.</param>
            <returns>The index.</returns>
        </member>
        <member name="M:System.Extensions.BitOperationsEx.GetNextSet(System.Int16,System.Int32)">
            <summary>
            Find a index of the binary representation of a value after the specified index,
            whose bit is set <see langword="true"/>.
            </summary>
            <param name="this">The value.</param>
            <param name="index">The index.</param>
            <returns>The index.</returns>
        </member>
        <member name="M:System.Extensions.BitOperationsEx.GetNextSet(System.Int32,System.Int32)">
            <summary>
            Find a index of the binary representation of a value after the specified index,
            whose bit is set <see langword="true"/>.
            </summary>
            <param name="this">The value.</param>
            <param name="index">The index.</param>
            <returns>The index.</returns>
        </member>
        <member name="M:System.Extensions.BitOperationsEx.GetNextSet(System.Int64,System.Int32)">
            <summary>
            Find a index of the binary representation of a value after the specified index,
            whose bit is set <see langword="true"/>.
            </summary>
            <param name="this">The value.</param>
            <param name="index">The index.</param>
            <returns>The index.</returns>
        </member>
        <member name="M:System.Extensions.BitOperationsEx.ReverseBits(System.Byte@)">
            <summary>
            <para>Reverse all bits in a specified value.</para>
            <para>
            Note that the value is passed by <b>reference</b> though the
            method is an extension method, and returns nothing.
            </para>
            </summary>
            <param name="this">The value.</param>
        </member>
        <member name="M:System.Extensions.BitOperationsEx.ReverseBits(System.Int16@)">
            <summary>
            <para>Reverse all bits in a specified value.</para>
            <para>
            Note that the value is passed by <b>reference</b> though the
            method is an extension method, and returns nothing.
            </para>
            </summary>
            <param name="this">The value.</param>
        </member>
        <member name="M:System.Extensions.BitOperationsEx.ReverseBits(System.Int32@)">
            <summary>
            <para>Reverse all bits in a specified value.</para>
            <para>
            Note that the value is passed by <b>reference</b> though the
            method is an extension method, and returns nothing.
            </para>
            </summary>
            <param name="this">The value.</param>
        </member>
        <member name="M:System.Extensions.BitOperationsEx.ReverseBits(System.Int64@)">
            <summary>
            <para>Reverse all bits in a specified value.</para>
            <para>
            Note that the value is passed by <b>reference</b> though the
            method is an extension method, and returns nothing.
            </para>
            </summary>
            <param name="this">The value.</param>
        </member>
        <member name="M:System.Extensions.BitOperationsEx.SetAt(System.Byte,System.Int32)">
            <summary>
            Get an <see cref="T:System.Int32"/> value, indicating that the absolute position of
            all set bits with the specified set bit order.
            </summary>
            <param name="this">The value.</param>
            <param name="order">The number of the order of set bits.</param>
            <returns>The position.</returns>
        </member>
        <member name="M:System.Extensions.BitOperationsEx.SetAt(System.Int16,System.Int32)">
            <summary>
            Get an <see cref="T:System.Int32"/> value, indicating that the absolute position of
            all set bits with the specified set bit order.
            </summary>
            <param name="this">The value.</param>
            <param name="order">The number of the order of set bits.</param>
            <returns>The position.</returns>
        </member>
        <member name="M:System.Extensions.BitOperationsEx.SetAt(System.Int32,System.Int32)">
            <summary>
            Get an <see cref="T:System.Int32"/> value, indicating that the absolute position of
            all set bits with the specified set bit order.
            </summary>
            <param name="this">The value.</param>
            <param name="order">The number of the order of set bits.</param>
            <returns>The position.</returns>
        </member>
        <member name="M:System.Extensions.BitOperationsEx.SetAt(System.Int64,System.Int32)">
            <summary>
            Get an <see cref="T:System.Int32"/> value, indicating that the absolute position of
            all set bits with the specified set bit order.
            </summary>
            <param name="this">The value.</param>
            <param name="order">The number of the order of set bits.</param>
            <returns>The position.</returns>
        </member>
        <member name="M:System.Extensions.BitOperationsEx.SkipSetBit(System.Byte,System.Int32)">
            <summary>
            Skip the specified number of set bits and iterate on the integer with other set bits.
            </summary>
            <param name="this">The integer to iterate.</param>
            <param name="setBitPosCount">Indicates how many set bits you want to skip to iterate.</param>
            <returns>The byte value that only contains the other set bits.</returns>
            <remarks>
            For example:
            <code>
            byte value = 0b00010111;
            foreach (int bitPos in value.SkipSetBit(2))
            {
                yield return bitPos + 1;
            }
            </code>
            You will get 3 and 5, because all set bit positions are 0, 1, 2 and 4, and we have skipped
            two of them, so the result set bit positions to iterate on are only 2 and 4.
            </remarks>
        </member>
        <member name="M:System.Extensions.BitOperationsEx.SkipSetBit(System.Int16,System.Int32)">
            <summary>
            Skip the specified number of set bits and iterate on the integer with other set bits.
            </summary>
            <param name="this">The integer to iterate.</param>
            <param name="setBitPosCount">Indicates how many set bits you want to skip to iterate.</param>
            <returns>The short value that only contains the other set bits.</returns>
            <remarks>
            For example:
            <code>
            byte value = 0b00010111;
            foreach (int bitPos in value.SkipSetBit(2))
            {
                yield return bitPos + 1;
            }
            </code>
            You will get 3 and 5, because all set bit positions are 0, 1, 2 and 4, and we have skipped
            two of them, so the result set bit positions to iterate on are only 2 and 4.
            </remarks>
        </member>
        <member name="M:System.Extensions.BitOperationsEx.SkipSetBit(System.Int32,System.Int32)">
            <summary>
            Skip the specified number of set bits and iterate on the integer with other set bits.
            </summary>
            <param name="this">The integer to iterate.</param>
            <param name="setBitPosCount">Indicates how many set bits you want to skip to iterate.</param>
            <returns>The int value that only contains the other set bits.</returns>
            <remarks>
            For example:
            <code>
            byte value = 0b00010111;
            foreach (int bitPos in value.SkipSetBit(2))
            {
                yield return bitPos + 1;
            }
            </code>
            You will get 3 and 5, because all set bit positions are 0, 1, 2 and 4, and we have skipped
            two of them, so the result set bit positions to iterate on are only 2 and 4.
            </remarks>
        </member>
        <member name="M:System.Extensions.BitOperationsEx.SkipSetBit(System.Int64,System.Int32)">
            <summary>
            Skip the specified number of set bits and iterate on the integer with other set bits.
            </summary>
            <param name="this">The integer to iterate.</param>
            <param name="setBitPosCount">Indicates how many set bits you want to skip to iterate.</param>
            <returns>The long value that only contains the other set bits.</returns>
            <remarks>
            For example:
            <code>
            byte value = 0b00010111;
            foreach (int bitPos in value.SkipSetBit(2))
            {
                yield return bitPos + 1;
            }
            </code>
            You will get 3 and 5, because all set bit positions are 0, 1, 2 and 4, and we have skipped
            two of them, so the result set bit positions to iterate on are only 2 and 4.
            </remarks>
        </member>
        <member name="M:System.Extensions.IndexEx.Deconstruct(System.Index@,System.Boolean@,System.Int32@)">
            <summary>
            Deconstruct the instance to multiple values, which allows you use the value tuple syntax
            to get the properties from an instance like:
            <code>
            var (variable1, variable2, variable3) = instance;
            </code>
            or like
            <code>
            (int variable1, double variable2, string? variable3) = instance;
            </code>
            </summary>
            <remarks>
            <para>
            The method should be declared manually when the type is a normal <see langword="struct"/>
            or <see langword="class"/>. If the method is in a <see langword="record"/>
            (or a <see langword="record struct"/>), the deconstruct method will be generated
            by the compiler automatically and returns <b>all properties</b>
            to those <see langword="out"/> parameters.
            </para>
            <para>
            Please note: If the deconstruct method is automatically generated by the compiler,
            you can't create a deconstruct method manually with the same number of the parameters
            than that auto method; otherwise, the method can't be called normally.
            </para>
            <para>
            In addition, the deconstruct methods can take <b>more than</b> 8 <see langword="out"/> parameters,
            although a normal <see cref="T:System.ValueTuple"/> can only contain at most 8 parameters.
            </para>
            </remarks>
            <seealso cref="T:System.ValueTuple"/>
        </member>
        <member name="T:System.IO.DirectoryEx">
            <summary>
            The directory extensions.
            </summary>
        </member>
        <member name="M:System.IO.DirectoryEx.CreateIfDoesNotExist(System.String)">
            <summary>
            Create the specified directory path when the path doesn't exist.
            </summary>
            <param name="path">The path.</param>
        </member>
        <member name="M:System.IO.DirectoryEx.DeleteWhenNoFilesInIt(System.String)">
            <summary>
            Delete the directory when the current directory doesn't contain any files.
            </summary>
            <param name="path">The path.</param>
            <returns>The <see cref="T:System.Boolean"/> result indicating whether the deletion is successful.</returns>
        </member>
        <member name="T:System.IO.Csv.CsvDocument">
            <summary>
            Introduces a <c>*.csv</c> document.
            </summary>
        </member>
        <member name="T:System.IO.Csv.CsvDocument.AsyncEnumerator">
            <summary>
            Indicates the enumerator that bounds with <see cref="M:System.IO.Csv.CsvDocument.GetAsyncEnumerator"/>.
            </summary>
            <seealso cref="M:System.IO.Csv.CsvDocument.GetAsyncEnumerator"/>
        </member>
        <member name="F:System.IO.Csv.CsvDocument.AsyncEnumerator._parser">
            <summary>
            Indicates the parser.
            </summary>
        </member>
        <member name="M:System.IO.Csv.CsvDocument.AsyncEnumerator.#ctor(Microsoft.VisualBasic.FileIO.TextFieldParser)">
            <summary>
            Initializes a <see cref="T:System.IO.Csv.CsvDocument.AsyncEnumerator"/> instance using the specified text parser.
            </summary>
            <param name="parser">The text field parser.</param>
        </member>
        <member name="P:System.IO.Csv.CsvDocument.AsyncEnumerator.Current">
            <inheritdoc cref="P:System.Collections.Generic.IAsyncEnumerator`1.Current"/>
        </member>
        <member name="M:System.IO.Csv.CsvDocument.AsyncEnumerator.MoveNextAsync">
            <inheritdoc cref="M:System.Collections.Generic.IAsyncEnumerator`1.MoveNextAsync"/>
        </member>
        <member name="F:System.IO.Csv.CsvDocument._parser">
            <summary>
            Indicates the reader of the document.
            </summary>
        </member>
        <member name="F:System.IO.Csv.CsvDocument._hasBeenDisposed">
            <summary>
            Indicates the value that suggests whether the document instance has been already disposed.
            </summary>
        </member>
        <member name="M:System.IO.Csv.CsvDocument.#ctor(System.String,System.Boolean,System.Char)">
            <summary>
            Initializes the <see cref="T:System.IO.Csv.CsvDocument"/> with the specified path, with two optional parameters.
            </summary>
            <param name="path">The path.</param>
            <param name="withHeader">Indicates whether the table contain the table header at the first line.</param>
            <param name="delimiter">
            The delimiter. This delimiter will be processed in splitting the line and
            separating to the multiple values. The default value is <see langword="default"/>(<see cref="T:System.Char"/>)
            (i.e. <c>'\0'</c>) as the undefined character.
            </param>
            <exception cref="T:System.IO.FileNotFoundException">Throws when the file can't be found.</exception>
        </member>
        <member name="P:System.IO.Csv.CsvDocument.WithHeader">
            <summary>
            Indicates whether the table contains the header.
            </summary>
        </member>
        <member name="P:System.IO.Csv.CsvDocument.LineNumber">
            <summary>
            Indicates the current line number.
            </summary>
        </member>
        <member name="P:System.IO.Csv.CsvDocument.Path">
            <summary>
            Indicates the path.
            </summary>
        </member>
        <member name="P:System.IO.Csv.CsvDocument.Delimiter">
            <summary>
            Indicates the delimiter.
            </summary>
        </member>
        <member name="M:System.IO.Csv.CsvDocument.Close">
            <summary>
            Closes the file, and releases the memory.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Throws when the memory has been already released.</exception>
        </member>
        <member name="M:System.IO.Csv.CsvDocument.GetFields">
            <summary>
            Try to get the fields of the table if worth. The table may contain those fields or not
            displayed at the first line.
            </summary>
            <returns>The result value. The value can be:
            <list type="table">
            <item>
            <term><see langword="null"/></term>
            <description>
            The property <see cref="P:System.IO.Csv.CsvDocument.WithHeader"/> is <see langword="false"/>, or the table is empty.
            </description>
            </item>
            <item>
            <term>The string of the field names</term>
            <description>Otherwise.</description>
            </item>
            </list>
            </returns>
            <seealso cref="P:System.IO.Csv.CsvDocument.WithHeader"/>
        </member>
        <member name="M:System.IO.Csv.CsvDocument.ReadLine">
            <summary>
            Reads a line of values.
            </summary>
            <returns>The values.</returns>
        </member>
        <member name="M:System.IO.Csv.CsvDocument.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>An enumerator that iterates through the collection.</returns>
        </member>
        <member name="M:System.IO.Csv.CsvDocument.GetAsyncEnumerator">
            <summary>
            Returns an enumerator that iterates asynchronously through the collection.
            </summary>
            <returns>An enumerator that iterates asynchronously through the collection.</returns>
        </member>
        <member name="M:System.IO.Csv.CsvDocument.System#IDisposable#Dispose">
            <inheritdoc/>
            <exception cref="T:System.ObjectDisposedException">Throws when the object has been already disposed.</exception>
        </member>
        <member name="T:System.IO.Csv.CsvDocument.Enumerator">
            <summary>
            Indicates the enumerator that bounds with <see cref="M:System.IO.Csv.CsvDocument.GetEnumerator"/>.
            </summary>
            <seealso cref="M:System.IO.Csv.CsvDocument.GetEnumerator"/>
        </member>
        <member name="F:System.IO.Csv.CsvDocument.Enumerator._parser">
            <summary>
            Indicates the parser.
            </summary>
        </member>
        <member name="M:System.IO.Csv.CsvDocument.Enumerator.#ctor(Microsoft.VisualBasic.FileIO.TextFieldParser)">
            <summary>
            Initializes a <see cref="T:System.IO.Csv.CsvDocument.Enumerator"/> instance using the specified text parser.
            </summary>
            <param name="parser">The text field parser.</param>
        </member>
        <member name="P:System.IO.Csv.CsvDocument.Enumerator.Current">
            <inheritdoc cref="P:System.Collections.IEnumerator.Current"/>
        </member>
        <member name="M:System.IO.Csv.CsvDocument.Enumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            Returns the value if:
            <list type="table">
            <item>
            <term><see langword="true"/></term>
            <description>If the enumerator was sucessfuly advanced to the next element.</description>
            </item>
            <item>
            <term><see langword="false"/></term>
            <description>If the enumerator has passed the end of the collection.</description>
            </item>
            </list>
            </returns>
        </member>
        <member name="T:System.ICloneable`1">
            <inheritdoc cref="T:System.ICloneable"/>
            <typeparam name="TClass">
            The type of this instance. This type should be only a class because the cloning
            operation is needed only in reference types, while the value types will be passed
            by value, at this time all value members (fields and properties) will be copied
            one by one.
            </typeparam>
            <remarks>
            Different with <see cref="T:System.ICloneable"/>, the cloneation
            has the same type with this existing instance.
            </remarks>
            <seealso cref="T:System.ICloneable"/>
        </member>
        <member name="M:System.ICloneable`1.Clone">
            <inheritdoc cref="M:System.ICloneable.Clone"/>
        </member>
        <member name="M:System.ICloneable`1.System#ICloneable#Clone">
            <inheritdoc/>
        </member>
        <member name="T:System.IValueComparable`1">
            <inheritdoc cref="T:System.IComparable`1"/>
            <typeparam name="TStruct">
            The type of objects to compare. Here it should be a <see langword="struct"/>.
            </typeparam>
        </member>
        <member name="M:System.IValueComparable`1.CompareTo(`0@)">
            <summary>
            Compares the current instance with another object of the same type and returns
            an integer that indicates whether the current instance precedes, follows, or
            occurs in the same position in the sort order as the other object.
            </summary>
            <param name="other">An object to compare with this instance.</param>
            <returns>
            A value that indicates the relative order of the objects being compared. The
            return value has these meanings:
            <list type="table">
            <listheader>
            <term>Value</term>
            <description>Meaning</description>
            </listheader>
            <item>
            <term><c><![CDATA[< 0]]></c></term>
            <description>This instance precedes other in the sort order.</description>
            </item>
            <item>
            <term><c>0</c></term>
            <description>This instance occurs in the same position in the sort order as other.</description>
            </item>
            <item>
            <term><c><![CDATA[> 0]]></c></term>
            <description>This instance follows other in the sort order.</description>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:System.IValueComparable`1.System#IComparable{TStruct}#CompareTo(`0)">
            <inheritdoc/>
        </member>
        <member name="T:System.IValueEquatable`1">
            <inheritdoc cref="T:System.IEquatable`1"/>
            <typeparam name="TStruct">
            The type of objects to compare. Here it should be a <see langword="struct"/>.
            </typeparam>
        </member>
        <member name="M:System.IValueEquatable`1.Equals(`0@)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            <see langword="true"/> if the current object is equal to the other parameter;
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:System.IValueEquatable`1.System#IEquatable{TStruct}#Equals(`0)">
            <inheritdoc/>
        </member>
        <member name="T:System.Text.RegularExpressions.InvalidRegexStringException">
            <summary>
            Indicates an error for reporting a string is an invalid regular expression.
            </summary>
        </member>
        <member name="M:System.Text.RegularExpressions.InvalidRegexStringException.#ctor">
            <inheritdoc/>
        </member>
        <member name="M:System.Text.RegularExpressions.InvalidRegexStringException.#ctor(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:System.Text.RegularExpressions.InvalidRegexStringException.#ctor(System.String,System.String)">
            <summary>
            Initializes an instance with the message and the regular expression.
            </summary>
            <param name="message">The message.</param>
            <param name="regex">The regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.InvalidRegexStringException.#ctor(System.String,System.Exception)">
            <inheritdoc/>
        </member>
        <member name="M:System.Text.RegularExpressions.InvalidRegexStringException.#ctor(System.String,System.String,System.Exception)">
            <summary>
            Initializes an instance with the message, wrong regular expression and the inner exception.
            </summary>
            <param name="message">The message.</param>
            <param name="regex">The regular expression.</param>
            <param name="innerException">The inner expression.</param>
        </member>
        <member name="P:System.Text.RegularExpressions.InvalidRegexStringException.WrongRegexString">
            <summary>
            Indicates the wrong regex string.
            </summary>
        </member>
        <member name="P:System.Text.RegularExpressions.InvalidRegexStringException.Message">
            <inheritdoc/>
        </member>
        <member name="T:System.Text.RegularExpressions.RegexAttribute">
            <summary>
            Indicates a data member is a regular expression value that represents using a <see cref="T:System.String"/>.
            </summary>
        </member>
        <member name="T:System.Text.ValueStringBuilder">
            <summary>
            Encapsulates a string builder implementation that is used via a <see langword="struct"/>.
            </summary>
            <remarks>
            You shouldn't use the parameterless constructor <see cref="M:System.Text.ValueStringBuilder.#ctor"/>.
            </remarks>
            <example>
            You can use this struct like this:
            <code>
            var sb = new ValueStringBuilder(stackalloc char[100]);
            
            // Appending operations...
            sb.Append("Hello");
            sb.Append(',');
            sb.Append("World");
            sb.Append('!');
            
            Console.WriteLine(sb.ToString()); // Dispose method will be called here.
            </code>
            </example>
            <seealso cref="M:System.Text.ValueStringBuilder.#ctor"/>
        </member>
        <member name="M:System.Text.ValueStringBuilder.CopyTo(System.Text.ValueStringBuilder@)">
            <summary>
            Try to copy the current instance to the specified builder.
            </summary>
            <param name="builder">The builder.</param>
            <exception cref="T:System.ArgumentException">
            Throws when the target argument doesn't contain the enough space.
            </exception>
        </member>
        <member name="M:System.Text.ValueStringBuilder.CopyTo(System.Text.StringBuilder)">
            <summary>
            Try to copy the current instance to the specified builder.
            </summary>
            <param name="builder">The builder.</param>
        </member>
        <member name="F:System.Text.ValueStringBuilder._chunk">
            <summary>
            Indicates the inner character series that is created by <see cref="T:System.Buffers.ArrayPool`1"/>.
            </summary>
            <remarks>
            <para>
            In the general cases, this field always keeps the <see langword="null"/> value. This
            field is not <see langword="null"/> when you calls the constructor <see cref="M:System.Text.ValueStringBuilder.#ctor(System.Int32)"/>
            because that constructor will be called if you want to create a large buffer.
            </para>
            <para>
            The field
            is as the same reference as the rent buffer array segment. If called that constructor,
            the inner code will execute <see cref="M:System.Buffers.ArrayPool`1.Rent(System.Int32)"/> to rent the specified number
            of bytes of buffer to be used, which won't allocate any memory.
            </para>
            <para>
            If the field is not <see langword="null"/> and when we calls the method <see cref="M:System.Text.ValueStringBuilder.ToString"/>,
            the buffer will be returned and the inner data will be released.
            </para>
            </remarks>
            <seealso cref="T:System.Buffers.ArrayPool`1"/>
            <seealso cref="M:System.Buffers.ArrayPool`1.Rent(System.Int32)"/>
            <seealso cref="M:System.Text.ValueStringBuilder.#ctor(System.Int32)"/>
            <seealso cref="M:System.Text.ValueStringBuilder.ToString"/>
        </member>
        <member name="F:System.Text.ValueStringBuilder._chars">
            <summary>
            Indicates the character pool.
            </summary>
        </member>
        <member name="M:System.Text.ValueStringBuilder.#ctor(System.String)">
            <summary>
            Initializes an instance with the specified string as the basic buffer.
            </summary>
            <param name="s">The string value.</param>
            <remarks>
            This constructor should be used when you know the maximum length of the return string. In addition,
            the string shouldn't be too long; below 300 (approximately) is okay.
            </remarks>
        </member>
        <member name="M:System.Text.ValueStringBuilder.#ctor(System.Span{System.Char}@)">
            <summary>
            Initializes an instance with the buffer specified as a <see cref="T:System.Span`1"/>.
            </summary>
            <param name="buffer">The initial buffer.</param>
            <remarks>
            <para>
            For the buffer, you can use the nested <see langword="stackalloc"/> expression to create
            a serial of buffer, such as <c>stackalloc char[10]</c>, where the length 10 is the value
            that holds the approximate maximum number of characters when output from your evaluation.
            </para>
            <para>
            You can also use the constructor: <see cref="M:System.Text.ValueStringBuilder.#ctor(System.Int32)"/> like:
            <code>
            var sb = new ValueStringBuilder(10);
            </code>
            The code is nearly equivalent to
            <code>
            var sb = new ValueStringBuilder(stackalloc char[10]);
            </code>
            but uses shared array pool (i.e. the property <see cref="P:System.Buffers.ArrayPool`1.Shared"/>)
            to create the buffer rather than using <see cref="T:System.Span`1"/>.
            </para>
            </remarks>
            <seealso cref="T:System.Span`1"/>
            <seealso cref="M:System.Text.ValueStringBuilder.#ctor(System.Int32)"/>
        </member>
        <member name="M:System.Text.ValueStringBuilder.#ctor(System.Int32)">
            <summary>
            Initializes an instance with the specified capacity.
            </summary>
            <param name="capacity">The capacity.</param>
        </member>
        <member name="P:System.Text.ValueStringBuilder.Length">
            <summary>
            Indicates the length of the string builder.
            </summary>
        </member>
        <member name="P:System.Text.ValueStringBuilder.Capacity">
            <summary>
            Indicates the total capacity.
            </summary>
        </member>
        <member name="P:System.Text.ValueStringBuilder.Item(System.Int32)">
            <summary>
            Gets the reference of a character at the specified index.
            </summary>
            <param name="index">The index.</param>
            <returns>The reference of the character.</returns>
            <remarks>
            This property returns a <see langword="ref"/> <see cref="T:System.Char"/>, which
            means you can use the return value to re-assign a new value, as the same behavior
            as the <see langword="set"/> accessor.
            </remarks>
        </member>
        <member name="M:System.Text.ValueStringBuilder.Equals(System.Text.ValueStringBuilder@,System.Text.ValueStringBuilder@)">
            <summary>
            Determines whether two instances has same values with the other instance.
            </summary>
            <param name="left">The left instance.</param>
            <param name="right">The right instance.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:System.Text.ValueStringBuilder.ToString">
            <summary>
            Returns the string result that is combined and constructed from the current instance,
            and then dispose the instance.
            </summary>
            <returns>The string representation.</returns>
            <remarks>
            <para>
            Please note that the dispose method will be invoked in the execution of this method <c>ToString</c>.
            Therefore, you can't or don't need to:
            <list type="bullet">
            <item>
            Use the keyword <see langword="using"/> onto the variable declaration, such as
            <c>using var sb = new ValueStringBuilder(stackalloc char[20]);</c>.
            </item>
            <item>
            Use the current string builder instance after had been called this method <c>ToString</c>.
            </item>
            </list>
            </para>
            <para>Because of the such behavior, this method isn't <see langword="readonly"/>.</para>
            </remarks>
        </member>
        <member name="M:System.Text.ValueStringBuilder.Dispose">
            <summary>
            To dispose the collection, all fields and properties will be cleared. In other words,
            this method is nearly equivalent to the code <c>this = default;</c>.
            </summary>
        </member>
        <member name="M:System.Text.ValueStringBuilder.Dispose(System.Boolean)">
            <summary>
            To dispose the collection. Although this method is <see langword="public"/>,
            you may not call this method, because this method will be called automatically when
            the method <see cref="M:System.Text.ValueStringBuilder.ToString"/> is called.
            </summary>
            <param name="clearAll">Indicates whether we should return the buffer.</param>
            <seealso cref="M:System.Text.ValueStringBuilder.ToString"/>
        </member>
        <member name="M:System.Text.ValueStringBuilder.EnsureCapacity(System.Int32)">
            <summary>
            To ensure the capacity in order to append characters into this collection.
            </summary>
            <param name="capacity">The capacity value to ensure.</param>
        </member>
        <member name="M:System.Text.ValueStringBuilder.Grow(System.Int32)">
            <summary>
            Resize the internal buffer either by doubling current buffer size or
            by adding <paramref name="additionalCapacityBeyondPos"/> to
            <see cref="P:System.Text.ValueStringBuilder.Length"/> whichever is greater.
            </summary>
            <param name="additionalCapacityBeyondPos">Number of chars requested beyond current position.</param>
            <seealso cref="P:System.Text.ValueStringBuilder.Length"/>
        </member>
        <member name="T:System.Text.ValueStringBuilder.Enumerator">
            <summary>
            Encapsulates the enumerator of this collection.
            </summary>
        </member>
        <member name="F:System.Text.ValueStringBuilder.Enumerator._length">
            <summary>
            Indicates the length.
            </summary>
        </member>
        <member name="F:System.Text.ValueStringBuilder.Enumerator._index">
            <summary>
            Indicates whether 
            </summary>
        </member>
        <member name="F:System.Text.ValueStringBuilder.Enumerator._ptr">
            <summary>
            Indicates the pointer that points to the current character.
            </summary>
        </member>
        <member name="M:System.Text.ValueStringBuilder.Enumerator.#ctor(System.Text.ValueStringBuilder@)">
            <summary>
            Initializes an instance with the specified character list specified as a <see cref="T:System.Span`1"/>.
            </summary>
            <param name="chars">The characters.</param>
            <seealso cref="T:System.Span`1"/>
        </member>
        <member name="P:System.Text.ValueStringBuilder.Enumerator.Current">
            <inheritdoc cref="P:System.Collections.IEnumerator.Current"/>
        </member>
        <member name="M:System.Text.ValueStringBuilder.Enumerator.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="M:System.Text.ValueStringBuilder.Enumerator.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
            <exception cref="T:System.NotSupportedException">Always throws.</exception>
        </member>
        <member name="M:System.Text.ValueStringBuilder.Enumerator.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
            <exception cref="T:System.NotSupportedException">Always throws.</exception>
        </member>
        <member name="M:System.Text.ValueStringBuilder.Enumerator.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
            <exception cref="T:System.NotSupportedException">Always throws.</exception>
        </member>
        <member name="M:System.Text.ValueStringBuilder.GetPinnableReference">
            <summary>
            <para>
            Get a pinnable reference to the builder.
            Does not ensure there is a null char after <see cref="P:System.Text.ValueStringBuilder.Length"/>.
            </para>
            <para>
            This overload is pattern matched in the C# 7.3+ compiler so you can omit
            the explicit method call, and write eg <c>fixed (char* c = builder)</c>.
            </para>
            </summary>
        </member>
        <member name="M:System.Text.ValueStringBuilder.GetPinnableReference(System.Boolean)">
            <summary>
            Get a pinnable reference to the builder.
            </summary>
            <param name="withTerminate">
            Ensures that the builder has a null character after <see cref="P:System.Text.ValueStringBuilder.Length"/>.
            </param>
            <seealso cref="P:System.Text.ValueStringBuilder.Length"/>
        </member>
        <member name="M:System.Text.ValueStringBuilder.Insert(System.Int32,System.Char,System.Int32)">
            <summary>
            Inserts a new character into the collection at the specified index.
            </summary>
            <param name="index">The index.</param>
            <param name="value">The character you want to insert into the collection.</param>
            <param name="count">The number.</param>
        </member>
        <member name="M:System.Text.ValueStringBuilder.Insert(System.Int32,System.String)">
            <summary>
            Inserts a new string into the collection at the specified index.
            </summary>
            <param name="index">The index you want to insert.</param>
            <param name="s">The string you want to insert.</param>
        </member>
        <member name="M:System.Text.ValueStringBuilder.Remove(System.Int32,System.Int32)">
            <summary>
            Remove a serial of characters from the specified index, with the specified length.
            </summary>
            <param name="startIndex">The start index.</param>
            <param name="length">The length you want to remove.</param>
            <remarks>
            This method will be costly (move a lot of elements), so you shouldn't call this method usually.
            </remarks>
        </member>
        <member name="M:System.Text.ValueStringBuilder.RemoveFromEnd(System.Int32)">
            <summary>
            Removes the specified number of characters from the end of the collection.
            </summary>
            <param name="length">The number of characters you want to remove.</param>
        </member>
        <member name="M:System.Text.ValueStringBuilder.Clear">
            <summary>
            To clear the builder.
            </summary>
        </member>
        <member name="M:System.Text.ValueStringBuilder.Append(System.Char)">
            <summary>
            Append a character at the tail of the collection.
            </summary>
            <param name="c">The character.</param>
        </member>
        <member name="M:System.Text.ValueStringBuilder.Append(System.Char,System.Int32)">
            <summary>
            Append a serial of same characters into the collection.
            </summary>
            <param name="c">The character.</param>
            <param name="count">The number of the character you want to append.</param>
        </member>
        <member name="M:System.Text.ValueStringBuilder.Append``1(``0)">
            <summary>
            Append a value.
            </summary>
            <typeparam name="TRefStruct">The type of the value.</typeparam>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Text.ValueStringBuilder.Append(System.String)">
            <summary>
            Append a string into the collection.
            </summary>
            <param name="s">The string.</param>
        </member>
        <member name="M:System.Text.ValueStringBuilder.Append(System.Char*,System.Int32)">
            <summary>
            Append a string that is represented as a <see cref="T:System.Char"/>*.
            </summary>
            <param name="value">The string.</param>
            <param name="length">The length of the string.</param>
        </member>
        <member name="M:System.Text.ValueStringBuilder.Append(System.ReadOnlySpan{System.Char}@)">
            <summary>
            Append a serial of characters.
            </summary>
            <param name="value">The characters.</param>
        </member>
        <member name="M:System.Text.ValueStringBuilder.AppendLine">
            <summary>
            Append a new line string.
            </summary>
        </member>
        <member name="M:System.Text.ValueStringBuilder.AppendLine(System.Object)">
            <summary>
            Append a new line string through the specified unknown typed instance.
            </summary>
            <param name="instance">The instance.</param>
        </member>
        <member name="M:System.Text.ValueStringBuilder.AppendLine(System.Char)">
            <summary>
            Append a character, and then append a new line string.
            </summary>
            <param name="c">The character.</param>
        </member>
        <member name="M:System.Text.ValueStringBuilder.AppendLine(System.Char,System.Int32)">
            <summary>
            Append a series of same characters, whose length is specified
            as the argument <paramref name="count"/>.
            </summary>
            <param name="c">The character.</param>
            <param name="count">The number of characters.</param>
        </member>
        <member name="M:System.Text.ValueStringBuilder.AppendLine(System.Char*,System.Int32)">
            <summary>
            Append a string that represented as a pointer.
            </summary>
            <param name="s">The string.</param>
            <param name="length">The length.</param>
        </member>
        <member name="M:System.Text.ValueStringBuilder.AppendLine(System.String)">
            <summary>
            Append a string, and then append a new line.
            </summary>
            <param name="s">The string.</param>
        </member>
        <member name="M:System.Text.ValueStringBuilder.AppendLine``1(``0)">
            <summary>
            Append a string representation of a specified instance, and then append a new line.
            </summary>
            <typeparam name="TRefStruct">The type of the instance.</typeparam>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Text.ValueStringBuilder.AppendLineRange``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Append a series of elements into the current collection.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="list">The list.</param>
        </member>
        <member name="M:System.Text.ValueStringBuilder.AppendRange``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Append a serial of strings from a serial of elements.
            </summary>
            <typeparam name="TUnmanaged">The type of each element.</typeparam>
            <param name="list">The list of elements.</param>
            <param name="separator">The separator when an element is finished to append.</param>
        </member>
        <member name="M:System.Text.ValueStringBuilder.AppendRange``1(System.Collections.Generic.IEnumerable{``0},,System.String)">
            <summary>
            Append a serial of strings converted from a serial of elements.
            </summary>
            <typeparam name="TUnmanaged">The type of each element.</typeparam>
            <param name="list">The list of elements.</param>
            <param name="converter">The converter.</param>
            <param name="separator">The separator when an element is finished to append.</param>
        </member>
        <member name="M:System.Text.ValueStringBuilder.AppendRange``1(``0*,System.Int32,System.String)">
            <summary>
            Append a serial of strings from a serial of elements specified as a pointer.
            </summary>
            <typeparam name="TUnmanaged">The type of each element.</typeparam>
            <param name="list">The list of elements.</param>
            <param name="length">The length of the list.</param>
            <param name="separator">The separator when an element is finished to append.</param>
        </member>
        <member name="M:System.Text.ValueStringBuilder.AppendRange``1(``0*,System.Int32,,System.String)">
            <summary>
            Append a serial of strings converted from a serial of elements specified as a pointer.
            </summary>
            <typeparam name="TUnmanaged">The type of each element.</typeparam>
            <param name="list">The list of elements.</param>
            <param name="length">The length of the list.</param>
            <param name="converter">The converter.</param>
            <param name="separator">The separator when an element is finished to append.</param>
        </member>
        <member name="M:System.Text.ValueStringBuilder.AppendSpan(System.Int32)">
            <summary>
            Append a span.
            </summary>
            <param name="length">The length of the characters.</param>
            <returns>The span.</returns>
        </member>
        <member name="M:System.Text.ValueStringBuilder.Reverse">
            <summary>
            Reverse the string builder instance. For example, if the list holds a string <c>"Hello"</c>,
            after called this method, the string will be <c>"olleH"</c>.
            </summary>
        </member>
        <member name="M:System.Text.ValueStringBuilder.AppendSlow(System.String)">
            <summary>
            Append a string.
            </summary>
            <param name="s">The string.</param>
        </member>
        <member name="M:System.Text.ValueStringBuilder.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
            <exception cref="T:System.NotSupportedException">Always throws.</exception>
        </member>
        <member name="M:System.Text.ValueStringBuilder.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
            <exception cref="T:System.NotSupportedException">Always throws.</exception>
        </member>
    </members>
</doc>
