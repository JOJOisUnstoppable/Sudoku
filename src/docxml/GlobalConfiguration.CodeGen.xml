<?xml version="1.0"?>
<doc>
    <assembly>
        <name>GlobalConfiguration.CodeGen</name>
    </assembly>
    <members>
        <member name="T:Microsoft.CodeAnalysis.CompilationExtensions">
            <summary>
            Provides extension methods on <see cref="T:Microsoft.CodeAnalysis.Compilation"/>.
            </summary>
            <seealso cref="T:Microsoft.CodeAnalysis.Compilation"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CompilationExtensions.GetTypeSymbol``1(Microsoft.CodeAnalysis.Compilation)">
            <summary>
            Try to get the <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/> result via the specified type instance
            specified as the type argument.
            </summary>
            <typeparam name="TNotNull">
            The type to get its corresponding <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/> instance as the return value.
            Due to the design of Roslyn, the type should be <see langword="notnull"/>, which means you cannot
            append nullable notation <c>?</c> onto the type, such as <see cref="T:System.Int32"/>? or <see cref="T:System.Object"/>?
            won't be compiled.
            </typeparam>
            <param name="this">The compilation instance.</param>
            <returns>The corresponding <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/> result.</returns>
            <seealso cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.GeneratorExecutionContextExtensions">
            <summary>
            Provides extension methods on <see cref="T:Microsoft.CodeAnalysis.GeneratorExecutionContext"/>.
            </summary>
            <seealso cref="T:Microsoft.CodeAnalysis.GeneratorExecutionContext"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.GeneratorExecutionContextExtensions.AddSource(Microsoft.CodeAnalysis.GeneratorExecutionContext@,System.String,System.String,System.String)">
            <summary>
            Simply calls <see cref="M:Microsoft.CodeAnalysis.GeneratorExecutionContext.AddSource(System.String,System.String)"/>.
            </summary>
            <param name="this">The current context.</param>
            <param name="fileName">The file name. The file name may be same as the symbol name</param>
            <param name="sourceGeneratorName">The source generator name.</param>
            <param name="sourceCode">The source code.</param>
            <seealso cref="M:Microsoft.CodeAnalysis.GeneratorExecutionContext.AddSource(System.String,System.String)"/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.INamedTypeSymbolExtensions">
            <summary>
            Provides extension methods for <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/>.
            </summary>
            <seealso cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.INamedTypeSymbolExtensions.GetAllMembers(Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Gets all possible members in a type, even including its base type members.
            </summary>
            <param name="this">The type symbol.</param>
            <returns>All members.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.INamedTypeSymbolExtensions.ToFileName(Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Get the file name of the type symbol.
            </summary>
            <param name="this">The symbol.</param>
            <returns>
            The file name. Due to the limited file name and the algorithm, if:
            <list type="bullet">
            <item>
            The character is <c><![CDATA['<']]></c> or <c><![CDATA['>']]></c>:
            Change them to <c>'['</c> and <c>']'</c>.
            </item>
            <item>The character is <c>','</c>: Change it to <c>'_'</c>.</item>
            <item>The character is <c>' '</c>: Remove it.</item>
            </list>
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.INamedTypeSymbolExtensions.GetTypeKindModifier(Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Gets the type kind modifier for a symbol.
            </summary>
            <param name="this">The named type symbol.</param>
            <returns>The string as the representation of the type kind modifier.</returns>
            <exception cref="T:System.ArgumentException">
            Throws when the current named type symbol holds an invalid case that doesn't contain
            any possible type kind modifier.
            </exception>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ISymbolExtensions">
            <summary>
            Provides with extension methods on <see cref="T:Microsoft.CodeAnalysis.ISymbol"/>.
            </summary>
            <seealso cref="T:Microsoft.CodeAnalysis.ISymbol"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ISymbolExtensions.GetMemberType(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Gets the type of the member specified as the base type <see cref="T:Microsoft.CodeAnalysis.ISymbol"/>.
            </summary>
            <param name="this">The type symbol.</param>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException">Throws when the argument is invalid.</exception>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MemberExistence">
            <summary>
            Provides extension methods on member existence checking.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MemberExistence.ExistField(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ISymbol},System.Func{Microsoft.CodeAnalysis.IFieldSymbol,System.Boolean},Microsoft.CodeAnalysis.IFieldSymbol@)">
            <summary>
            Determines whether the member symbol collection contains a specified field.
            </summary>
            <param name="this">The collection.</param>
            <param name="predicate">The condition to satisfy.</param>
            <param name="result">The found result.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MemberExistence.ExistProperty(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ISymbol},System.Func{Microsoft.CodeAnalysis.IPropertySymbol,System.Boolean},Microsoft.CodeAnalysis.IPropertySymbol@)">
            <summary>
            Determines whether the member symbol collection contains a specified property.
            </summary>
            <param name="this">The collection.</param>
            <param name="predicate">The condition to satisfy.</param>
            <param name="result">The found result.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PropertySymbolExtensions">
            <summary>
            Proivdes extension methods on <see cref="T:Microsoft.CodeAnalysis.IPropertySymbol"/>.
            </summary>
            <seealso cref="T:Microsoft.CodeAnalysis.IPropertySymbol"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PropertySymbolExtensions.IsAutoProperty(Microsoft.CodeAnalysis.IPropertySymbol)">
            <summary>
            Determine whether the current property is auto-implemented property.
            </summary>
            <param name="this">The property symbol.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SyntaxReferenceExtensions">
            <summary>
            Provides extension methods on <see cref="T:Microsoft.CodeAnalysis.SyntaxReference"/>.
            </summary>
            <seealso cref="T:Microsoft.CodeAnalysis.SyntaxReference"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxReferenceExtensions.ToLocation(Microsoft.CodeAnalysis.SyntaxReference)">
            <summary>
            Creates a <see cref="T:Microsoft.CodeAnalysis.Location"/> instance as the result value
            via the specified <see cref="T:Microsoft.CodeAnalysis.SyntaxReference"/>.
            </summary>
            <param name="this">The instance.</param>
            <returns>The <see cref="T:Microsoft.CodeAnalysis.Location"/> result.</returns>
        </member>
        <member name="T:System.Collections.Generic.EnumerableExtensions">
            <summary>
            Provides extension methods on <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <seealso cref="T:System.Collections.Generic.IEnumerable`1"/>
        </member>
        <member name="M:System.Collections.Generic.EnumerableExtensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            The method to replace with <see langword="foreach"/> loop.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="this">The collection to iterate.</param>
            <param name="action">The action that is executed while iterating.</param>
        </member>
        <member name="T:System.Collections.Generic.ICollectionExtensions">
            <summary>
            Provides extension methods on <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <seealso cref="T:System.Collections.Generic.ICollection`1"/>
        </member>
        <member name="M:System.Collections.Generic.ICollectionExtensions.ForEach``1(System.Collections.Generic.ICollection{``0},System.Action{``0})">
            <summary>
            Performs the specified action on each element of the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <typeparam name="T">The type of the each element.</typeparam>
            <param name="this">The collection itself.</param>
            <param name="action">The action.</param>
        </member>
        <member name="T:System.Collections.Generic.KeyValuePairExtensions">
            <summary>
            Provides with the extension methods on type <see cref="T:System.Collections.Generic.KeyValuePair`2"/>.
            </summary>
            <seealso cref="T:System.Collections.Generic.KeyValuePair`2"/>
        </member>
        <member name="M:System.Collections.Generic.KeyValuePairExtensions.Deconstruct``2(System.Collections.Generic.KeyValuePair{``0,``1},``0@,``1@)">
            <summary>
            Deconstruct the instance of type <see cref="T:System.Collections.Generic.KeyValuePair`2"/> into two values:
            <list type="table">
            <item>
            <term><see cref="P:System.Collections.Generic.KeyValuePair`2.Key"/></term>
            <description>The key.</description>
            </item>
            <item>
            <term><see cref="P:System.Collections.Generic.KeyValuePair`2.Value"/></term>
            <description>The value.</description>
            </item>
            </list>
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="this">The instance to be deconstructed.</param>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
        </member>
        <member name="T:System.Text.RegularExpressions.RegexExtensions">
            <summary>
            Provides extension methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.
            </summary>
            <seealso cref="T:System.Text.RegularExpressions.Regex"/>
        </member>
        <member name="M:System.Text.RegularExpressions.RegexExtensions.TryMatch(System.String,System.String,System.Text.RegularExpressions.Match@)">
            <summary>
            Try to match the specified pattern using the specified input value, and gets the result.
            If failed to match or even any exceptions thrown, the method will return <see langword="false"/>,
            and the argument <paramref name="result"/> will keep the <see langword="null"/> value.
            </summary>
            <param name="input">The input string.</param>
            <param name="pattern">The pattern to match.</param>
            <param name="result">The result <see cref="T:System.Text.RegularExpressions.Match"/> instance.</param>
            <returns>The <see cref="T:System.Boolean"/> value indicating whether the operation is successful.</returns>
            <remarks>
            Please note that <see cref="P:System.Text.RegularExpressions.Group.Success"/> being <see langword="false"/> doesn't mean
            the return value is also <see langword="false"/>. The return value just check for the case
            whether any exceptions thrown.
            </remarks>
            <seealso cref="P:System.Text.RegularExpressions.Group.Success"/>
        </member>
        <member name="T:System.StringExtensions">
            <summary>
            Provides with extension methods on <see cref="T:System.String"/>.
            </summary>
            <seealso cref="T:System.String"/>
        </member>
        <member name="M:System.StringExtensions.ToCamelCase(System.String)">
            <summary>
            Convertes the specified string value as the camel-casing.
            </summary>
            <param name="this">The string.</param>
            <returns>The converted string value.</returns>
        </member>
        <member name="T:System.Xml.XmlDocumentExtensions">
            <summary>
            Provides extension methods on <see cref="T:System.Xml.XmlDocument"/>.
            </summary>
            <seealso cref="T:System.Xml.XmlDocument"/>
        </member>
        <member name="M:System.Xml.XmlDocumentExtensions.OnLoading(System.Xml.XmlDocument,System.String)">
            <summary>
            Try to load the XML document located to the specified path.
            </summary>
            <param name="this">The current XML document instance.</param>
            <param name="path">The path to load.</param>
            <returns>The current reference to the XML document.</returns>
        </member>
        <member name="T:System.Index">
            <summary>
            Represent a type can be used to index a collection either from the start or the end.
            </summary>
            <remarks>
            Index is used by the C# compiler to support the new index syntax
            <code>
            int[] someArray = new int[5] { 1, 2, 3, 4, 5 } ;
            int lastElement = someArray[^1]; // lastElement = 5
            </code>
            </remarks>
        </member>
        <member name="M:System.Index.#ctor(System.Int32,System.Boolean)">
            <summary>
            Construct an Index using a value and indicating if the index is from the start or from the end.
            </summary>
            <param name="value">The index value. it has to be zero or positive number.</param>
            <param name="fromEnd">Indicating if the index is from the start or from the end.</param>
            <remarks>
            If the Index constructed from the end, index value 1 means pointing at the last element
            and index value 0 means pointing at beyond last element.
            </remarks>
        </member>
        <member name="P:System.Index.Start">
            <summary>Create an Index pointing at first element.</summary>
        </member>
        <member name="P:System.Index.End">
            <summary>Create an Index pointing at beyond last element.</summary>
        </member>
        <member name="P:System.Index.Value">
            <summary>Returns the index value.</summary>
        </member>
        <member name="P:System.Index.IsFromEnd">
            <summary>Indicates whether the index is from the start or the end.</summary>
        </member>
        <member name="M:System.Index.FromStart(System.Int32)">
            <summary>Create an Index from the start at the position indicated by the value.</summary>
            <param name="value">The index value from the start.</param>
        </member>
        <member name="M:System.Index.FromEnd(System.Int32)">
            <summary>Create an Index from the end at the position indicated by the value.</summary>
            <param name="value">The index value from the end.</param>
        </member>
        <member name="M:System.Index.GetOffset(System.Int32)">
            <summary>Calculate the offset from the start using the giving collection length.</summary>
            <param name="length">The length of the collection that the Index will be used with. length has to be a positive value</param>
            <remarks>
            For performance reason, we don't validate the input length parameter and the returned offset value against negative values.
            we don't validate either the returned offset is greater than the input length.
            It is expected Index will be used with collections which always have non negative length/count. If the returned offset is negative and
            then used to index a collection will get out of range exception which will be same affect as the validation.
            </remarks>
        </member>
        <member name="M:System.Index.Equals(System.Object)">
            <summary>Indicates whether the current Index object is equal to another object of the same type.</summary>
            <param name="value">An object to compare with this object</param>
        </member>
        <member name="M:System.Index.Equals(System.Index)">
            <summary>Indicates whether the current Index object is equal to another Index object.</summary>
            <param name="other">An object to compare with this object</param>
        </member>
        <member name="M:System.Index.GetHashCode">
            <summary>Returns the hash code for this instance.</summary>
        </member>
        <member name="M:System.Index.ToString">
            <summary>Converts the value of the current Index object to its equivalent string representation.</summary>
        </member>
        <member name="M:System.Index.op_Implicit(System.Int32)~System.Index">
            <summary>Converts integer number to an Index.</summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.IsExternalInit">
            <summary>
            Declare this to get init properties.
            </summary>
            <remarks>
            Please see
            <see href="https://github.com/dotnet/roslyn/issues/45510#issuecomment-694977239">this link</see>
            to learn more details about this type.
            </remarks>
        </member>
        <member name="T:System.Range">
            <summary>Represent a range has start and end indexes.</summary>
            <remarks>
            Range is used by the C# compiler to support the range syntax.
            <code>
            int[] someArray = new int[5] { 1, 2, 3, 4, 5 };
            int[] subArray1 = someArray[0..2]; // { 1, 2 }
            int[] subArray2 = someArray[1..^0]; // { 2, 3, 4, 5 }
            </code>
            </remarks>
        </member>
        <member name="M:System.Range.#ctor(System.Index,System.Index)">
            <summary>Construct a Range object using the start and end indexes.</summary>
            <param name="start">Represent the inclusive start index of the range.</param>
            <param name="end">Represent the exclusive end index of the range.</param>
        </member>
        <member name="P:System.Range.Start">
            <summary>Represent the inclusive start index of the Range.</summary>
        </member>
        <member name="P:System.Range.End">
            <summary>Represent the exclusive end index of the Range.</summary>
        </member>
        <member name="P:System.Range.All">
            <summary>Create a Range object starting from first element to the end.</summary>
        </member>
        <member name="M:System.Range.Equals(System.Object)">
            <summary>Indicates whether the current Range object is equal to another object of the same type.</summary>
            <param name="value">An object to compare with this object</param>
        </member>
        <member name="M:System.Range.Equals(System.Range)">
            <summary>Indicates whether the current Range object is equal to another Range object.</summary>
            <param name="other">An object to compare with this object</param>
        </member>
        <member name="M:System.Range.GetHashCode">
            <summary>Returns the hash code for this instance.</summary>
        </member>
        <member name="M:System.Range.ToString">
            <summary>Converts the value of the current Range object to its equivalent string representation.</summary>
        </member>
        <member name="M:System.Range.StartAt(System.Index)">
            <summary>Create a Range object starting from start index to the end of the collection.</summary>
        </member>
        <member name="M:System.Range.EndAt(System.Index)">
            <summary>Create a Range object starting from first element in the collection to the end Index.</summary>
        </member>
        <member name="M:System.Range.GetOffsetAndLength(System.Int32)">
            <summary>Calculate the start offset and length of range object using a collection length.</summary>
            <param name="length">The length of the collection that the range will be used with. length has to be a positive value.</param>
            <remarks>
            For performance reason, we don't validate the input length parameter against negative values.
            It is expected Range will be used with collections which always have non negative length/count.
            We validate the range is inside the length scope though.
            </remarks>
        </member>
        <member name="T:Sudoku.Diagnostics.CodeGen.Generators.GlobalConfigValueGenerator">
            <summary>
            Defines the incremental source generator that is used for the generation on sync the solution version.
            </summary>
        </member>
        <member name="M:Sudoku.Diagnostics.CodeGen.Generators.GlobalConfigValueGenerator.Initialize(Microsoft.CodeAnalysis.IncrementalGeneratorInitializationContext)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Diagnostics.CodeGen.TypeFormats">
            <summary>
            Provides <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayFormat"/> instance that is for types.
            </summary>
        </member>
        <member name="F:Sudoku.Diagnostics.CodeGen.TypeFormats.FullNameWithConstraints">
            <summary>
            Indicates the type format that is the full name of the type,
            and is with type argument constraints.
            </summary>
        </member>
        <member name="F:Sudoku.Diagnostics.CodeGen.TypeFormats.FullName">
            <summary>
            Indicates the type format that is the full name of the type,
            and is without type argument constraints.
            </summary>
        </member>
    </members>
</doc>
