namespace Sudoku.Diagnostics.CodeGen.Generators;

/// <summary>
/// Defines a source generator that generates the source code that are options used in logical solver type.
/// </summary>
[Generator(LanguageNames.CSharp)]
public sealed class LogicalSolverOperationsGenerator : IIncrementalGenerator
{
	/// <inheritdoc/>
	public void Initialize(IncrementalGeneratorInitializationContext context)
		=> context.RegisterSourceOutput(
			context.CompilationProvider,
			(spc, compilation) =>
			{
				if (compilation is not { Assembly: { Name: Projects.SudokuCore, GlobalNamespace: var @namespace } assemblySymbol })
				{
					return;
				}

				var manualSolverTypeSymbol = compilation.GetTypeByMetadataName("Sudoku.Solving.Logics.LogicalSolver");
				if (manualSolverTypeSymbol is not { TypeKind: Kind.Class, IsRecord: false, IsSealed: true })
				{
					// The core type cannot be found.
					return;
				}

				var stepSearcherType = compilation.GetTypeByMetadataName("Sudoku.Solving.Logics.Prototypes.IStepSearcher");
				if (stepSearcherType is not { TypeKind: Kind.Interface })
				{
					// Same reason as above.
					return;
				}

				var attributeType = compilation.GetTypeByMetadataName("Sudoku.Runtime.AnalysisServices.StepSearcherPropertyAttribute");
				if (attributeType is not { TypeKind: Kind.Class, IsSealed: true })
				{
					// Same reason as above.
					return;
				}

				// Iterates on all possible types derived from this interface.
				var allTypes = @namespace.GetAllNestedTypes();
				var foundResultInfos = new List<FoundResultInfo>();
				foreach (var searcherType in
					from typeSymbol in allTypes
					where typeSymbol is
					{
						TypeKind: Kind.Class,
						AllInterfaces: var implementedInterfaces and not []
					} && implementedInterfaces.Contains(stepSearcherType, SymbolEqualityComparer.Default)
					select typeSymbol)
				{
					foreach (var property in searcherType.GetMembers().OfType<IPropertySymbol>())
					{
						if (!property.ContainsAttribute(attributeType))
						{
							continue;
						}

						if (property is not
							{
								ExplicitInterfaceImplementations: [],
								ContainingType.Name: var searcherTypeName,
								Name: var propertyName
							})
						{
							continue;
						}

						var searcherFullTypeName = $"Sudoku.Solving.Logics.Prototypes.I{searcherTypeName}";
						var interfaceType = compilation.GetTypeByMetadataName(searcherFullTypeName);
						if (interfaceType is not { AllInterfaces: var interfaceBaseInterfaces })
						{
							continue;
						}

						if (interfacePropertyMatcher(interfaceType))
						{
							foundResultInfos.Add(new(property, interfaceType, interfaceType));
						}
						else if (interfaceBaseInterfaces.FirstOrDefault(interfacePropertyMatcher) is { } baseInterfaceType)
						{
							foundResultInfos.Add(new(property, interfaceType, baseInterfaceType));
						}


						bool interfacePropertyMatcher(INamedTypeSymbol e)
							=> e.GetMembers().OfType<IPropertySymbol>().Any(p => p.Name == property.Name);
					}
				}

				var targetPropertiesCode = string.Join(
					"\r\n\r\n\t",
					from info in foundResultInfos
					let typeStr = info.DerivedInterfaceType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
					let propertyContainedInterfaceTypeStr = info.PropertyContainedInterfaceType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
					let typeStrWithoutInterfacePrefix = info.Property.ContainingType.Name
					let propertyStr = info.Property.Name
					let propertyTypeStr = info.Property.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
					select
						$$"""
						/// <inheritdoc cref="{{propertyContainedInterfaceTypeStr}}.{{propertyStr}}"/>
							[global::System.CodeDom.Compiler.GeneratedCodeAttribute("{{GetType().FullName}}", "{{VersionValue}}")]
							[global::System.Runtime.CompilerServices.CompilerGeneratedAttribute]
							public {{propertyTypeStr}} {{typeStrWithoutInterfacePrefix}}_{{propertyStr}}
							{
								[global::System.Runtime.CompilerServices.MethodImplAttribute(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
								set
								{
									if (TargetSearcherCollection.GetOfType<{{typeStr}}>() is { } searcher)
									{
										searcher.{{propertyStr}} = value;
									}
								}
							}
						"""
				);

				spc.AddSource(
					$"ManualSolver.g.{Shortcuts.ManualSolverOptions}.cs",
					$$"""
					// <auto-generated/>

					#nullable enable

					namespace Sudoku.Solving.Logics;

					partial class LogicalSolver
					{
						{{targetPropertiesCode}}
					}
					"""
				);
			}
		);
}

internal readonly record struct FoundResultInfo(
	IPropertySymbol Property,
	INamedTypeSymbol DerivedInterfaceType,
	INamedTypeSymbol PropertyContainedInterfaceType
);
