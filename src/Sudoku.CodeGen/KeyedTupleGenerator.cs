using System;
using System.Runtime.CompilerServices;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace Sudoku.CodeGen
{
	/// <summary>
	/// Define a keyed tuple generator.
	/// </summary>
	[Generator]
	public sealed class KeyedTupleGenerator : ISourceGenerator
	{
		/// <summary>
		/// Indicates the separator that is used for separating multiple values.
		/// </summary>
		private const string CommaToken = ", ";


		/// <summary>
		/// Indicates whether the project uses tabs <c>'\t'</c> as indenting characters.
		/// </summary>
		private static readonly bool UsingTabsAsIndentingCharacters = true;

		/// <summary>
		/// Indicates the new line character in this current environment.
		/// </summary>
		private static readonly string NewLine = Environment.NewLine;


		/// <inheritdoc/>
		public void Execute(GeneratorExecutionContext context)
		{
			var sb = new StringBuilder();
			for (int length = 2; length <= 4; length++)
			{
				sb.Clear();
				sb.AppendLine(PrintHeader());
				sb.AppendLine(PrintPragmaWarningDisableCS8509());
				sb.AppendLine();
				sb.AppendLine(PrintNullableEnable());
				sb.AppendLine();
				sb.AppendLine(PrintUsingDirectives());
				sb.AppendLine();
				sb.AppendLine(PrintNamespace());
				sb.AppendLine(PrintOpenBracketToken());
				sb.AppendLine(PrintRecordDocComment(length));
				sb.AppendLine(PrintCompilerGenerated());
				sb.AppendLine(PrintRecordStatement(length));
				sb.AppendLine(PrintOpenBracketToken(1));
				sb.AppendLine(PrintUserDefinedConstructorDocComment(length));
				sb.AppendLine(PrintUserDefinedConstructor(length));
				sb.AppendLine(PrintOpenBracketToken(2));
				sb.AppendLine(PrintClosedBracketToken(2));
				sb.AppendLine();
				sb.AppendLine();
				sb.AppendLine(PrintInheritDoc());
				sb.AppendLine(PrintLength(length));
				sb.AppendLine();
				sb.AppendLine();
				sb.AppendLine(PrintInheritDoc());
				sb.AppendLine(PrintIndexerWithValue(length));
				sb.AppendLine();
				sb.AppendLine();
				sb.AppendLine(PrintInheritDoc());
				sb.AppendLine(PrintToStringWithValue());
				sb.AppendLine(PrintClosedBracketToken(1));
				sb.AppendLine(PrintClosedBracketToken());

				context.AddSource(
					hintName: $"KeyedTuple_{length.ToString()}.cs",
					sourceText: SourceText.From(
						text: sb.ToString(),
						encoding: Encoding.UTF8
					)
				);
			}
		}

		/// <inheritdoc/>
		public void Initialize(GeneratorInitializationContext context)
		{
		}


		private static string PrintOpenBracketToken(int indentingCount = 0) => indentingCount == 0 ? "{" : $"{new string('\t', indentingCount)}{{";
		private static string PrintClosedBracketToken(int indentingCount = 0) => indentingCount == 0 ? "}" : $"{new string('\t', indentingCount)}}}";
		private static string PrintHeader() =>
			new StringBuilder()
			.AppendLine("//")
			.AppendLine("// <auto-generated>")
			.AppendLine("//     This file is generated by compiler, powered by source generator.")
			.AppendLine("// </auto-generated>")
			.AppendLine("//")
			.ToString();
		private string PrintPragmaWarningDisableCS8509() => "#pragma warning disable 8509";
		private static string PrintUsingDirectives() => "using System.Runtime.CompilerServices;";
		private static string PrintNullableEnable() => "#nullable enable";
		private static string PrintNamespace() => "namespace System.Collections.Generic";
		private static string PrintCompilerGenerated()
		{
			const int o = 9;

			const string name = nameof(CompilerGeneratedAttribute);
			return $"{(UsingTabsAsIndentingCharacters ? "\t" : "    ")}[{name.Substring(0, name.Length - o)}]";
		}
		private static string PrintRecordDocComment(int length)
		{
			var sb = new StringBuilder();
			sb.Append(UsingTabsAsIndentingCharacters ? "\t" : "    ");
			sb.AppendLine("/// <summary>");
			sb.Append(UsingTabsAsIndentingCharacters ? "\t" : "    ");
			sb.AppendLine("/// Provides a tuple with a primary element, which means the tuple contains multiple items,");
			sb.Append(UsingTabsAsIndentingCharacters ? "\t" : "    ");
			sb.AppendLine("/// but the only specified item can be output as <see cref=\"string\"/> text.");
			sb.Append(UsingTabsAsIndentingCharacters ? "\t" : "    ");
			sb.AppendLine("/// </summary>");

			for (int i = 1; i <= length; i++)
			{
				sb
					.Append(UsingTabsAsIndentingCharacters ? "\t" : "    ")
					.Append("/// <typeparam name=\"T")
					.Append(i)
					.Append("\">The type of the property <see cref=\"KeyedTuple{");

				for (int j = 1; j <= length; j++)
				{
					sb.Append('T').Append(j).Append(CommaToken);
				}

				sb
					.Remove(sb.Length - CommaToken.Length, CommaToken.Length)
					.Append("}.Item")
					.Append(i)
					.AppendLine("\"/>.</typeparam>");
			}

			for (int i = 1; i <= length; i++)
			{
				sb
					.Append(UsingTabsAsIndentingCharacters ? "\t" : "    ")
					.Append("/// <param name=\"Item")
					.Append(i)
					.Append("\">The ")
					.Append(i);

				switch (i)
				{
					case 1 when i / 10 != 1: sb.Append("st"); break;
					case 2 when i / 10 != 1: sb.Append("nd"); break;
					case 3 when i / 10 != 1: sb.Append("rd"); break;
					default: sb.Append("th"); break;
				}

				sb.AppendLine(" item.</param>");
			}

			sb
				.Append(UsingTabsAsIndentingCharacters ? "\t" : "    ")
				.Append("/// <param name=\"PriorKey\">The prior key.</param>");

			return sb.ToString();
		}
		private static string PrintRecordStatement(int length)
		{
			var sb = new StringBuilder();
			sb.Append(UsingTabsAsIndentingCharacters ? "\t" : "    ");
			sb.Append("public sealed record KeyedTuple<");

			for (int i = 1; i <= length; i++)
			{
				sb.Append('T').Append(i).Append(CommaToken);
			}
			sb.Remove(sb.Length - CommaToken.Length, CommaToken.Length).Append(">(");
			for (int i = 1; i <= length; i++)
			{
				sb.Append('T').Append(i).Append(' ').Append("Item").Append(i).Append(CommaToken);
			}
			sb.Append("int PriorKey) : ITuple");
			return sb.ToString();
		}
		private static string PrintUserDefinedConstructorDocComment(int length)
		{
			var sb = new StringBuilder();
			sb.Append(UsingTabsAsIndentingCharacters ? "\t\t" : "        ");
			sb.AppendLine("/// <summary>");
			sb.Append(UsingTabsAsIndentingCharacters ? "\t\t" : "        ");
			sb.AppendLine($"/// Initializes an instance with the specified {length.ToString()} items, and the first one is the prior key.");
			sb.Append(UsingTabsAsIndentingCharacters ? "\t\t" : "        ");
			sb.AppendLine("/// </summary>");
			for (int i = 1; i <= length; i++)
			{
				sb
					.Append(UsingTabsAsIndentingCharacters ? "\t\t" : "        ")
					.Append("/// <param name=\"item")
					.Append(i)
					.Append("\">The item ")
					.Append(i)
					.AppendLine(".</param>");
			}

			sb.Remove(sb.Length - NewLine.Length, NewLine.Length);

			return sb.ToString();
		}
		private static string PrintUserDefinedConstructor(int length)
		{
			var sb = new StringBuilder();
			sb.Append(UsingTabsAsIndentingCharacters ? "\t\t" : "        ");
			sb.Append("public KeyedTuple(");
			for (int i = 1; i <= length; i++)
			{
				sb.Append('T').Append(i).Append(' ').Append("item").Append(i).Append(CommaToken);
			}
			sb.Remove(sb.Length - CommaToken.Length, CommaToken.Length).Append(')');
			if (length <= 4)
			{
				sb.Append(" : this(");
			}
			else
			{
				sb
					.AppendLine()
					.Append(UsingTabsAsIndentingCharacters ? "\t\t\t" : "            ")
					.Append(": this(");
			}

			for (int i = 1; i <= length; i++)
			{
				sb.Append("item").Append(i).Append(CommaToken);
			}
			sb.Append(1).Append(')');
			return sb.ToString();
		}
		private static string PrintInheritDoc() => UsingTabsAsIndentingCharacters ? "\t\t/// <inheritdoc/>" : "        /// <inheritdoc/>";
		private static string PrintLength(int length) => $"{(UsingTabsAsIndentingCharacters ? "\t\t" : "        ")}int ITuple.Length => {length.ToString()};";
		private static string PrintIndexerWithValue(int length)
		{
			var sb = new StringBuilder();
			sb.Append(UsingTabsAsIndentingCharacters ? "\t\t" : "        ");
			sb.Append("object? ITuple.this[int index] =>");
			if (length <= 4)
			{
				sb.Append(' ').Append(PrintIndexerValue(false, length));
			}
			else
			{
				sb.AppendLine().Append(PrintIndexerValue(true, length));
			}

			return sb.ToString();
		}
		private static string PrintIndexerValue(bool withIndent, int length)
		{
			var sb = new StringBuilder();
			if (withIndent)
			{
				sb.Append(UsingTabsAsIndentingCharacters ? "\t\t\t" : "            ");
			}
			sb.Append("index switch { ");
			for (int i = 1; i <= length; i++)
			{
				sb.Append(i).Append(" => ").Append("Item").Append(i).Append(CommaToken);
			}
			sb.Remove(sb.Length - CommaToken.Length, CommaToken.Length).Append(" };");

			return sb.ToString();
		}
		private static string PrintToStringWithValue() => $"{(UsingTabsAsIndentingCharacters ? "\t\t" : "        ")}public override string ToString() => ((ITuple)this)[PriorKey]?.ToString() ?? string.Empty;";
	}
}
