# 引用结构
## 什么是 `ref` 关键字

要讲 `ref struct`，就得提起 `ref` 关键字。`ref` 关键字是 C# 语言使用指针的灵魂语法，它表示一个引用，来做到我们用数值传递做不到的事情，例如值类型对象传递函数参数时，一般都不会要求传递的对象在函数执行过程之中同步改变内部的数据，但如果用到了呢？Java 出于无奈只有使用类变量（即全局的变量）来达到这一点。但有些时候，这样的操作并不是非常方便的。于是，C# 里提供了这个关键字来表达一个参数以应用传递，例如下面的代码。

```c#
private static void Swap<T>(ref T left, ref T right) where T : struct
{
    var temp = left;
    left = right;
    right = temp;
}
```

比如上面的代码就达到了这一点。当值传递时，这个用于交换的函数只能交换函数传递过来的对象，而原本的对象并没有达到交换操作，所以必须加上 `ref` 关键字来表示这个对象和原本的对象是同一个对象，函数内交换也影响原本的对象。

今天要说到的 `ref struct`，和 `ref` 的语义有所不同。



## 连续栈内存？

在之前的内容里，我们讲到了不少的指针的内容，而说得最多的就是 C 语言里令人吐槽的数组。数组在 C 语言统统都是栈内存分配，这使得你在函数内定义的数组都无法通过返回的方式“出”这个函数。如果迫不得已，我们只能使用堆内存声明方式，但有些复杂：

```c
int *arr = (int *)malloc(sizeof(int) * 10);
```

例如这个代码，声明了一个堆内存的数组变量 `arr`，存的都是 `int` 类型的元素，且占据 10 个元素的空间大小。

不过，C# 的所有数组都是被封装为对象了，所以一个 `new` 关键字就搞定了内存分配，但分配在堆内存里。如果想在 C# 里声明栈内存的数组的话，将使用的是 `stackalloc` 关键字：

```c#
int *arr = stackalloc int[10];
```

例如上面这个代码，语义就和 C 语言的 `int arr[10] = { 0 };` 是一样的意思。不过，这样分配需要使用指针，而指针总是会容易出错，所以我们想要一种语法，不用到指针，也能实现类型安全。于是，`ref struct` 诞生了。

如果标记一个结构表示一组自定义的连续内存，且只能在栈内存里分配的话，那么，在 C# 7 里就可以使用 `ref struct` 啦！只要你把你自定义的结构用上 `ref` 关键字修饰，那么这个对象声明出来就一定是一组连续分配的栈内存对象了。

```c#
public ref struct A
{
    ...
}
```

或者原本带有 `readonly` 关键字时的 `readonly ref struct`：

```c#
public readonly ref struct A
{
    ...
}
```

前者没有 `readonly`，表示这组内存里的内容可变；后者有 `readonly`，表示这组内存里的内容不可变。



## 那么，`ref struct` 对象有哪些特性呢？

试想一下，既然这块内存被定义为栈内存分配，那么只能在栈内存里生存的东西有些什么样的特效呢？回忆一下，引用类型一定产生在堆内存里，而值类型也可以通过装箱进入引用类型存储到堆内存之中，例如：

```c#
object i = 3; // Boxing.
```

可是，明明 `i` 存储的东西就只是一个单纯的 `int`，是一个值类型，那岂不是一个看起来像是 bug 一样的存在？是的。这里就要说明了，由于 `ref struct` 以栈内存分配，所以对象只可能存储在栈内存里，故它无法以任何形式存储到堆栈里。所以，`ref struct` 对象无法实现接口（因为接口会产生可能的装箱和拆箱操作）、无法赋值和隐式转换为引用类型。这是它的第一个特点。

第二个特点。既然是栈内存对象，那么很明显，任何一个堆内存的对象也无法把它作为成员存储到堆内存之中。所以 `ref struct` 对象也无法作为一个不是 `ref struct` 类型对象的任何成员，例如字段和属性。这句话有点绕，说白了就是，如果我有一个类 `A`，那么它就不能在字段和属性里使用 `ref struct` 的对象；即使这个对象是结构类型（值类型），但它可能装箱，所以这个结构类型也不允许拥有任何字段或属性是 `ref struct` 类型的。当然，它也不能作为任何一个类型的泛型参数，比如，`List<一个 ref struct 类型>` 的写法是不允许的。

第三个特点。带了隐藏状态机的函数体是无法使用 `ref struct` 的本地变量的。栈内存对象就无法使用迭代器了，因为迭代器使用其它的非 `ref struct` 的对象作为辅助输出，所以很显然，这样的做法是不可以的，所以，`ref struct` 对象也不能作为迭代器对象，更不能放在迭代器的执行语句之中（迭代器执行语句就是使用 `yield return` 和 `yield break` 语句的那个函数体）。同样地，使用了状态机的 `async` 方法里也不允许使用 `ref struct` 对象。

第四个特点，也是比较隐讳的特点。如果 `ref struct` 对象放在特殊函数体里，比如 Lambda 表达式或本地函数里的时候，这样的对象就无法被捕获到。原因也很简单。在 Lambda 表达式转换为本地函数或普通函数时，捕获的变量将使用 `ref` 关键字修饰，来表示两个引用的位置是指向同一个内存的。如果你捕获了 `ref struct` 对象，它再被 `ref` 关键字修饰，就显得格外奇怪和不正常。这也是为什么，微软 C# 语言团队将这种对象名称定为 `ref struct` 的原因（因为它考虑到你不可能再为它加 `ref` 关键字修饰了）。

所以，说了这么多，`ref struct` 禁止做的事情也算是非常多，这都仅仅因为它只放在栈内存里。这些条条款款也都是很严谨的。

总结（拿出 MSDN 的原话）：

> 保持 `ref struct` 类型作为堆栈分配的变量的目标引入了几条编译器针对所有 `ref struct` 类型强制执行的规则。
>
> * 不能对 `ref struct` 装箱。<br/>无法向属于 `object`、`dynamic` 或任何接口类型的变量分配 `ref struct` 类型。
> * `ref struct` 类型不能实现接口。
> * 不能将 `ref struct` 声明为类或常规结构的字段成员。<br/>这包括声明自动实现的属性，后者会创建一个由编译器生成的支持字段。
> * 不能声明异步方法中属于 `ref struct` 类型的本地变量。<br/>不能在返回类似 [`Task`](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task)、[`Task<TResult>`](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task-1) 或 `Task` 类型的同步方法中声明它们。
> * 无法在迭代器中声明 `ref struct` 本地变量。
> * 无法捕获 Lambda 表达式或本地函数中的 `ref struct` 变量。
>
> 这些限制可确保不会以可提升至托管堆的方式意外地使用 `ref struct`。



## 那么，它还有什么用？

既然限制这么多，那么 `ref struct` 就会很难用才对。实际上相反。考虑一下，字符串是堆内存对象（引用类型），但如果对字符串操作的话，显然是会比较慢的。那么，如果把一些不是很长的字符串放到堆内存里操作，那么它应当很快。是的，我们使用一个 `ref struct`，把字符串存储到里面，就可以安全快捷地操作它们了。实际上，微软提供的 API 已经带有一个默认的 `ref struct` 对象：`Span<T>` 和 `ReadOnlySpan<T>`。前者是可更改内部元素的 `ref struct`，而后者则是一组只读连续内存 `readonly ref struct`。

我们可以使用 `Span<T>` 快捷地操作一系列字符串，而它们仅仅存储到栈内存之中：

```c#
var span = "Hello, world!".ToSpan();
span[4] = '!';
span[5] = ' ';

foreach (char c in span)
{
    Console.Write(c);
}
Console.WriteLine();
```

这样的话，`"Hello, world!"` 就被成功存储到栈内存里。然后第 4 个字符被替换为 `'!'`，第 5 个字符被替换为 `' '`，所以输出的结果是 `"Hell!  world!"`。

你可以使用 `Span<T>` 做到很多意想不到的东西，而且效率也是非常高，但请你注意的是，`Span<T>` 类型自带的泛型参数 `T` 只能是我们常用的几大值类型数据类型；换而言之，你是无法使用 `Span<string>` 的。

> 请注意对比。C++ 语言里可以对 `struct` 和 `class` 使用 `ref` 关键字。在 C++ 里，`struct` 和 `class` 没有语义区别，只有用法区别（`struct` 的默认访问优先级为 `public`，而 `class` 则是 `private`），所以，C++ 还允许 `ref class`。但是，C++ 里的 `ref struct` 和 `ref class` 表示这个对象被生存周期约束。当对象不再被引用时会被自动释放掉，它和 C# 的语义不同，所以需要你作出对比。



## 说了这么多，我还是不习惯使用它？

注意，`Span<T>` 类型非常常见。当你书写的代码想要加快运行速度，且同时保证类型安全的话，`Span<T>` 是一个非常好的选择。但由于各种类型约束，你可能只能在常见结构和类类型对象里的函数体内使用（比如函数内部的**局部变量**或是函数传参时，作为**参数**传递，因为它们就是最常见的栈内存变量）。



## 可释放的 `ref struct`

在 C# 8 里，考虑到 `ref struct` 可能是一组较大的连续内存块，存储到栈内存里使得栈内存一直得不到释放，并最终爆栈，引起不可捕获的 `StackOverflowException`，所以 C# 8 里立马为 `ref struct` 加上了释放功能。这是一个语义语法，它不需要修改你的任何代码（例如关键字等），只需要加入原本就有的语法，写一个 `Dispose` 方法后，就可以释放了，这样就避免了你使用 `IDisposable` 接口（因为 `ref struct` 不允许实现接口）。



## 总结

总结起来，`ref struct` 对象就是一组连续栈内存分配的值类型对象，这种类型对象由于一定是存储在栈内存里，所以无法以任何方式转换为引用类型存储到堆内存之中。所以上面说的一大堆操作都做不到。但是，它提供了快速和类型安全的执行效果，避免了显式使用指针。显式使用指针需要 `unsafe` 块标记不说，还要一大堆复杂的语法，而且还总可能产生意外的致命错误，所以，请尽快把 `ref struct` 用起来吧！