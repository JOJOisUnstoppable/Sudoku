# 伪代码约定
Issue 里给出了一些伪代码的写法，这里大概说一下我的伪代码到底是怎么写的。

首先，伪代码模拟了 C# 的语法格式，不过替换了词汇改成了中文，比如说：

* `if`：如果；
* `for`：变量 啥啥啥 从 多少 到 多少 循环，一次增大 几 个单位；
* `foreach`：就 啥啥啥 于 什么集合 来说；
* `operator []`：中文的“【】”符号；
* `//`：冒号“：”来表示注释。

其它的就没啥变化了。

参考例子：

```
：
：死亡绽放搜索函数
：
就 当前候选数 于 所有候选数 来说
    ：故意设候选数为真
    当前单元格 = 当前候选数 / 9
    当前数值 = 当前候选数 % 9
    盘面【当前单元格】 = 当前候选数 ：设盘面的当前候选数为真

    ：确定候选数的关联 ALS（待定数组）
    所有关联的待定数组 = 获取关联待定数组（当前候选数）

    ：然后把关联的 ALS 里的所有这个数字都改为假（相当于作了排除）
    就 当前关联待定数组 于 所有关联的待定数组 来说
        就 单元格 于 获取待定数组涉及的所有单元格（当前关联待定数组） 来说
            盘面【单元格，当前候选数】 = 假

    ：检测是否有格子因为 ALS 降阶为数组后删空
    就 当前关联待定数组 于 所有关联的待定数组 来说
        列表 = 获取所有候选数（当前关联待定数组）
        区域编号 = 获取待定数组所在区域（当前关联待定数组）

        ：模拟数组进行删数
        按数组形式删数（盘面，区域编号，列表）

    ：检测是否删空（基本类型）
    变量 格子 从 0 到 80 循环，一次增大 1 个单位
        如果 获取所有候选数（盘面，格子） = 空 的话
            ：死亡绽放找到了
            记录死亡绽放信息（盘面，当前候选数，所有关联的待定数组）

    ：另外，进阶类型 1 和 2，只需要把前面的“删空格子”这个条件换成“ALS 变作数组和负秩数组”就行了，
    ：这里就不给出实现的伪代码了，因为写法也差不多。
```