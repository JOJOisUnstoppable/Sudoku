# 使用 `Cells` 结构

`Cells` 是一个结构体，这意味着它是一个值类型。这个类型大致是一个由 2 个 `long` 构成的一个盘面单元格使用表。一个实例可以表示一个盘面某个时刻下，使用到的单元格序列。

这个数据结构只会使用一共 128 比特里的其中 81 个比特，两个 `long` 数值都只会使用大约 40 个比特。

你可以使用下面这样的代码来创建例子：

```csharp
// An instance with the third cell set.
var exemplar = new Cells { 3 };

// An instance with two cells set.
var exemplar2 = new Cells(new[] { 3, 5 });
var exemplar3 = new Cells(stackalloc[] { 3, 5 });
var examplar4 = new Cells { 3, 5 };

// An instance with 21 cells set:
// * * * | * * * | * * *
// * * * | . . . | . . .
// * * * | . . . | . . .
// ------+-------+------
// . . * | . . . | . . .
// . . * | . . . | . . .
// . . * | . . . | . . .
// ------+-------+------
// . . * | . . . | . . .
// . . * | . . . | . . .
// . . * | . . . | . . .
var exemplar5 = new Cells(2);

// An instance with 20 cells set:
// * * . | * * * | * * *
// * * * | . . . | . . .
// * * * | . . . | . . .
// ------+-------+------
// . . * | . . . | . . .
// . . * | . . . | . . .
// . . * | . . . | . . .
// ------+-------+------
// . . * | . . . | . . .
// . . * | . . . | . . .
// . . * | . . . | . . .
var exemplar6 = new Cells(2, false);
```

> 最后一个构造器 `.ctor(int, bool)` 是一个私有方法，这意味着你无法从结构外部调用它。如果你需要使用这个构造器，请你使用 `Sudoku.Constants.Processings` 这个静态类下面的 [`Peers`](https://github.com/SunnieShine/Sudoku/blob/master/Sudoku.Core/Constants/Processings.Fields.cs#L62) 这个数组来获取。

你可以查看 [`Cells.cs`](https://github.com/SunnieShine/Sudoku/blob/master/Sudoku.Core/Data/Cells.cs) 来了解更多有关其他构造器的信息。

## `Empty` 单例

我们可以使用 `Cells.Empty` 这个提供好的实例，得到一个空表。它等价于 `default(Cells)` 或者 `new Cells()`。不过，我依然建议你使用 `Cells.Empty` 而不是使用默认构造器实例化出来的对象。

```csharp
var singleton = Cells.Empty;
```

## 使用该对象的运算符

当我们需要计算一些单元格使用情况的包含关系时，它将非常有用。

我们可以使用 `&` 运算符来得到一个表，这个表包含所有两个表格里都包含的单元格：

```csharp
var map1 = new Cells(3, false);
var map2 = new Cells(12, false);
var map = map1 & map2;

// * * . | * * * | * * *     . . . | * * * | . . .     . . . | * * * | . . .
// * * * | . . . | . . .     * * * | . * * | * * *     * * * | . . . | . . .
// * * * | . . . | . . .     . . . | * * * | . . .     . . . | . . . | . . .
// ------+-------+------     ------+-------+------     ------+-------+------
// . . * | . . . | . . .     . . . | * . . | . . .     . . . | . . . | . . .
// . . * | . . . | . . .  &  . . . | * . . | . . .  =  . . . | . . . | . . .
// . . * | . . . | . . .     . . . | * . . | . . .     . . . | . . . | . . .
// ------+-------+------     ------+-------+------     ------+-------+------
// . . * | . . . | . . .     . . . | * . . | . . .     . . . | . . . | . . .
// . . * | . . . | . . .     . . . | * . . | . . .     . . . | . . . | . . .
// . . * | . . . | . . .     . . . | * . . | . . .     . . . | . . . | . . .
```

这样你就可以得到一个新的表格，这个表格包含的单元格仅仅是两个表格包含的单元格都能“看”到的地方。

如果你想要得到两个表一共用到了哪些单元格，你可以使用 `|` 运算符.

```csharp
var map1 = new Cells(3, false);
var map2 = new Cells(12, false);
var map = map1 | map2;

// * * . | * * * | * * *     . . . | * * * | . . .     * * . | * * * | * * *
// * * * | . . . | . . .     * * * | . * * | * * *     * * * | . * * | * * *
// * * * | . . . | . . .     . . . | * * * | . . .     * * * | * * * | . . .
// ------+-------+------     ------+-------+------     ------+-------+------
// . . * | . . . | . . .     . . . | * . . | . . .     . . * | * . . | . . .
// . . * | . . . | . . .  |  . . . | * . . | . . .  =  . . * | * . . | . . .
// . . * | . . . | . . .     . . . | * . . | . . .     . . * | * . . | . . .
// ------+-------+------     ------+-------+------     ------+-------+------
// . . * | . . . | . . .     . . . | * . . | . . .     . . * | * . . | . . .
// . . * | . . . | . . .     . . . | * . . | . . .     . . * | * . . | . . .
// . . * | . . . | . . .     . . . | * . . | . . .     . . * | * . . | . . .
```

如果你要获取两个表里，只出现在其中一个表里的单元格序列，你需要使用 `^` 运算符。

```csharp
var map1 = new Cells(3, false);
var map2 = new Cells(12, false);
var map = map1 ^ map2;

// * * . | * * * | * * *     . . . | * * * | . . .     * * . | . . . | * * *
// * * * | . . . | . . .     * * * | . * * | * * *     . . . | . * * | * * *
// * * * | . . . | . . .     . . . | * * * | . . .     * * * | * * * | . . .
// ------+-------+------     ------+-------+------     ------+-------+------
// . . * | . . . | . . .     . . . | * . . | . . .     . . * | * . . | . . .
// . . * | . . . | . . .  ^  . . . | * . . | . . .  =  . . * | * . . | . . .
// . . * | . . . | . . .     . . . | * . . | . . .     . . * | * . . | . . .
// ------+-------+------     ------+-------+------     ------+-------+------
// . . * | . . . | . . .     . . . | * . . | . . .     . . * | * . . | . . .
// . . * | . . . | . . .     . . . | * . . | . . .     . . * | * . . | . . .
// . . * | . . . | . . .     . . . | * . . | . . .     . . * | * . . | . . .
```

另外，如果你只需要获得第一个表里有的单元格，但第二个表格里不含有的单元格，你需要使用减法运算符 `-`。

```csharp
var map1 = new Cells(3, false);
var map2 = new Cells(12, false);
var map = map1 - map2;

// * * . | * * * | * * *     . . . | * * * | . . .     * * . | . . . | * * *
// * * * | . . . | . . .     * * * | . * * | * * *     . . . | . . . | . . .
// * * * | . . . | . . .     . . . | * * * | . . .     * * * | . . . | . . .
// ------+-------+------     ------+-------+------     ------+-------+------
// . . * | . . . | . . .     . . . | * . . | . . .     . . * | . . . | . . .
// . . * | . . . | . . .  -  . . . | * . . | . . .  =  . . * | . . . | . . .
// . . * | . . . | . . .     . . . | * . . | . . .     . . * | . . . | . . .
// ------+-------+------     ------+-------+------     ------+-------+------
// . . * | . . . | . . .     . . . | * . . | . . .     . . * | . . . | . . .
// . . * | . . . | . . .     . . . | * . . | . . .     . . * | . . . | . . .
// . . * | . . . | . . .     . . . | * . . | . . .     . . * | . . . | . . .
```

最后，如果你要取反一个表，你可以使用 `~` 运算符。

```csharp
var map1 = new Cells(3, false);
var map = ~map1;

//    * * . | * * * | * * *     . . * | . . . | . . .
//    * * * | . . . | . . .     . . . | * * * | * * *
//    * * * | . . . | . . .     . . . | * * * | * * *
//    ------+-------+------     ------+-------+------
//    . . * | . . . | . . .     * * . | * * * | * * *
// ~  . . * | . . . | . . .  =  * * . | * * * | * * *
//    . . * | . . . | . . .     * * . | * * * | * * *
//    ------+-------+------     ------+-------+------
//    . . * | . . . | . . .     * * . | * * * | * * *
//    . . * | . . . | . . .     * * . | * * * | * * *
//    . . * | . . . | . . .     * * . | * * * | * * *
```

## `CoveredRegions` 和 `Regions` 属性

如果你想要得到这个表格里所有单元格都在的区域，你可以使用属性 `CoveredRegions` 获得所有这些区域。其中 `0..9` 表示宫索引，`9..18` 表示行索引，而 `18..27` 表示列索引。

```csharp
var regions1 = new Cells { 0, 1 }.CoveredRegions; // Two elements: 0 and 9.
var regions2 = new Cells { 0, 3 }.CoveredRegions; // One element: 9.
var regions3 = new Cells { 0, 1, 27, 28 }.CoveredRegions; // No element.
```

返回值类型是 `IEnumerable<int>`，这意味着你可以使用 `foreach` 循环来获取它们。

```csharp
foreach (int region in someCells.CoveredRegions)
{
    // Code using the region.
}
```

但是，如果你要获取结构所有占据的区域，你需要使用属性 `Regions`。

```csharp
var regions1 = new Cells { 0, 1 }.CoveredRegions; // Four elements: 0, 9, 18, 19.
var regions2 = new Cells { 0, 3 }.CoveredRegions; // Four elements: 0, 9, 18, 21.
var regions3 = new Cells { 0, 1, 27, 28 }.CoveredRegions; // Six elements: 0, 3, 9, 12, 18, 19.
```

## 使用 `foreach`

你可以直接使用 `foreach` 循环获取这个数据结构的所有已经存入的单元格序列。

```csharp
var map = new Cells { 0, 3, 6, 9, 12, 15, 18, 21, 24 };
foreach (int cell in map)
{
    // Code using each cell.
    int row = cell / 9 + 1, column = cell % 9 + 1;
    Console.WriteLine($"r{r}c{c}");
}
```

