<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ output extension=".cs" #>
/*
 * File: KeyedTuple.cs
 * Namespace: System (extension)
 *
 * This file is generated by compiler, powered by text template (T4).
**/

using System.Runtime.CompilerServices;
using Sudoku.Constants;
using Sudoku.Extensions;

namespace System
{
<#
const int target = 4;
for (int current = 2; current <= target; current++)
{#>
	/// <summary>
	/// Provides a tuple with a primary element, which means the tuple contains multiple items,
	/// but the only specified item can be output as <see cref="string"/> text.
	/// </summary>
	<#
	for (int i = 1; i <= current; i++)
	{#>/// <typeparam name="T<#= i #>">The type of the property <see cref="KeyedTuple{<#
		for (int t = 1; t <= current; t++)
		{#>T<#= t #><#
			if (t != current)
			{#>, <#
			}
		}#>}.Item<#= i #>"/>.</typeparam>
	<#}#>/// <param name="PriorKey">The prior key.</param>
	public sealed record KeyedTuple<<#
	for (int i = 1; i <= current; i++)
	{#>T<#= i #><#
		if (i != current)
		{#>, <#
		}
	}#>>(<#
	for (int i = 1; i <= current; i++)
	{#>T<#= i #> Item<#= i #>, <#
	}#>int PriorKey) : ITuple
	{
		/// <summary>
		/// Initializes an instance with the specified <#= current #> items, and the first one is the prior key.
		/// </summary>
		<#
		for (int i = 1; i <= current; i++)
		{#>/// <param name="item<#= i #>">The item <#= i #>.</param>
		<#}#>public KeyedTuple(<#
		for (int i = 1; i <= current; i++)
		{#>T<#= i #> item<#= i #><#
			if (i != current)
			{#>, <#
			}
		}#>) : this(<#
		for (int i = 1; i <= current; i++)
		{#>item<#= i #>, <#
		}#>1)
		{
		}


		/// <inheritdoc/>
		int ITuple.Length => <#= current #>;


		/// <inheritdoc/>
		object? ITuple.this[int index] =><#
		if (current > 2)
		{#>
		
			<#
		}
		else
		{#> <#
		}#>PriorKey switch { <#
		for (int i = 1; i <= current; i++)
		{#><#= i #> => Item<#= i #>, <#
		}
		#>_ => Throwings.ImpossibleCase };


		/// <inheritdoc/>
		public override string ToString() => ((ITuple)this)[PriorKey].NullableToString();
	}
<#
	if (current != target)
	{#>

<#
	}
}#>
}
