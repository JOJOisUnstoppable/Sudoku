using System;
using System.Text;
using Microsoft.CodeAnalysis;
using Sudoku.Extensions;

namespace Sudoku.SourceGenerating.KeyedTuple
{
	/// <summary>
	/// Indicates the keyed tuple source generator.
	/// </summary>
	[Generator]
	public sealed class KeyedTupleSourceGenerator : ISourceGenerator
	{
		/// <summary>
		/// Indicates the separator.
		/// </summary>
		private const string Separator = ", ";


		/// <inheritdoc/>
		public void Execute(GeneratorExecutionContext context)
		{
			const int target = 4;
			for (int current = 2; current <= target; current++)
			{
				var sb = new StringBuilder()
					.AppendLine("/*")
					.Append(" * File: KeyedTuple")
					.Append(current)
					.AppendLine(".cs")
					.AppendLine(" * Namespace: System (extension)")
					.AppendLine(" *")
					.AppendLine(" * This file is generated by compiler, powered by text template (T4).")
					.AppendLine("**/")
					.AppendLine()
					.AppendLine("using System.Runtime.CompilerServices;")
					.AppendLine("using Sudoku.Extensions;")
					.AppendLine("namespace System")
					.AppendLine('{')
					.Append("\t/// <summary>")
					.Append("\t/// Provides a tuple with a primary element, which means the tuple contains multiple items,")
					.Append("\t/// but the only specified item can be output as <see cref=\"string\"/> text.")
					.Append("\t/// </summary>");

				for (int i = 1; i <= current; i++)
				{
					sb
						.AppendLine()
						.Append("\t/// <typeparam name=\"T")
						.Append(i)
						.Append(@""">The type of the property <see cref=""KeyedTuple{")
						.Append(GetGenericParamsList(current))
						.Append("}.Item")
						.Append(i)
						.Append(@"""/>.</typeparam>");
				}

				sb
					.AppendLine("\t/// <param name=\"PriorKey\">The prior key.</param>")
					.Append("\tpublic sealed record KeyedTuple<")
					.Append(GetGenericParamsList(current))
					.Append(">(")
					.Append(GetParamsList(n: current, upperCase: true, withPriorKey: true, withType: true))
					.AppendLine(") : ITuple")
					.AppendLine("\t{")
					.AppendLine("\t\t/// <summary>")
					.Append("\t\t/// Initializes an instance with the specified ")
					.Append(current)
					.AppendLine(" items, and the first one is the prior key.")
					.AppendLine("\t\t/// </summary>");

				for (int i = 1; i <= current; i++)
				{
					sb
						.Append("\t\t/// <param name=\"item")
						.Append(i)
						.Append("\">The item ")
						.Append(i)
						.AppendLine(".</param>");
				}

				sb
					.Append("\t\tpublic KeyedTuple(")
					.Append(GetParamsList(n: current, upperCase: false, withPriorKey: false, withType: true))
					.Append(") : this(")
					.Append(GetParamsList(n: current, upperCase: false, withPriorKey: false, withType: false))
					.AppendLine("1)")
					.AppendLine("\t\t{")
					.AppendLine("\t\t}")
					.AppendLine()
					.AppendLine()
					.AppendLine("\t\t/// <inheritdoc/>")
					.Append("\t\tint ITuple.Length => ")
					.Append(current)
					.AppendLine(';')
					.AppendLine()
					.AppendLine()
					.AppendLine("\t\t/// <inheritdoc/>")
					.AppendLine("\t\tobject? ITuple.this[int index] =>")
					.Append("\t\t\tPriorKey switch { ")
					.Append(GetSwitchList(current))
					.AppendLine(" };")
					.AppendLine()
					.AppendLine()
					.AppendLine("\t\t/// <inheritdoc/>")
					.AppendLine("\t\tpublic override string ToString() => ((ITuple)this)[PriorKey].NullableToString();")
					.AppendLine("\t}")
					.AppendLine('}');

				context.AddSource($"KeyedTuple{current}.cs", sb.ToString());
			}
		}

		/// <inheritdoc/>
		public void Initialize(GeneratorInitializationContext context)
		{
		}


		private static string GetSwitchList(int n)
		{
			var sb = new StringBuilder();

			for (int i = 1; i <= n; i++)
			{
				sb.Append(i).Append(" => ").Append("Item").Append(i).Append(Separator);
			}

			return sb.RemoveFromEnd(Separator.Length).ToString();
		}

		private static string GetParamsList(int n, bool upperCase, bool withPriorKey, bool withType)
		{
			var sb = new StringBuilder();
			for (int i = 1; i <= n; i++)
			{
				if (withType)
				{
					sb
						.Append('T')
						.Append(i)
						.Append(' ');
				}

				sb
					.Append(upperCase ? "Item" : "item")
					.Append(i)
					.Append(Separator);
			}

			return (withPriorKey ? sb.Append("int PriorKey") : sb.RemoveFromEnd(Separator.Length)).ToString();
		}

		private static string GetGenericParamsList(int elements)
		{
			var genericParamsList = new StringBuilder();
			for (int i = 1; i <= elements; i++)
			{
				genericParamsList.Append('T').Append(i).Append(Separator);
			}
			genericParamsList.RemoveFromEnd(Separator.Length);

			return genericParamsList.ToString();
		}
	}
}
